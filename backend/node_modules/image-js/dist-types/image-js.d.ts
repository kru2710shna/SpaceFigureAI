import type { BitDepth as BitDepth_2 } from 'fast-png';
import { decode as decode_2 } from 'tiff';
import type { PngEncoderOptions } from 'fast-png';

/**
 *
 * Calculate a new image that is the sum between the current image and the otherImage.
 * @param image - Image to which to add.
 * @param otherImage - Image to add.
 * @returns The summed image.
 */
export declare function add(image: Image_2, otherImage: Image_2): Image_2;

export declare interface AffineTransform {
    /**
     * Translation of source points along x and y axes.
     */
    translation: Point;
    /**
     * Clockwise angle in degrees.
     */
    rotation: number;
    /**
     * Scaling factor from source to destination.
     */
    scale: number;
}

/**
 * Aligns two images by finding the translation that minimizes the mean difference of all channels.
 * between them. The source image should fit entirely in the destination image.
 * @param source - Image to align.
 * @param destination - Image to align to.
 * @param options - Align images min difference options.
 * @returns Translation that minimizes the mean difference between the images.
 * Gives the origin of the source image relatively to the top-left corner of the destination image.
 */
export declare function alignMinDifference(source: Image_2, destination: Image_2, options?: AlignMinDifferenceOptions): {
    row: number;
    column: number;
    similarity: number;
};

export declare interface AlignMinDifferenceOptions {
    /**
     * Initial step size by which the images will be translated.
     * @default `Math.max(Math.round(Math.min(source.width, source.height, Math.max(xSpan, ySpan)) / 10,),1,)`
     */
    startStep?: number;
    mask?: Mask;
}

/**
 * Perform an AND operation on two masks.
 * @param mask - First mask.
 * @param otherMask - Second mask.
 * @param options - And options.
 * @returns AND of the two masks.
 */
export declare function and(mask: Mask, otherMask: Mask, options?: AndOptions): Mask;

export declare interface AndOptions {
    /**
     * Image to which the resulting image has to be put.
     */
    out?: Mask;
}

/**
 * Bit depth of the image (nb of bits that encode each value in the image).
 */
export declare type BitDepth = 1 | 8 | 16;

export declare type BitValue = 1 | 0 | boolean;

/**
 * Blur an image. The pixel in the center becomes an average of the surrounding ones.
 * @param image - Image to blur.
 * @param options - Blur options.
 * @returns The blurred image.
 */
declare function blur_2(image: Image_2, options: BlurOptions): Image_2;
export { blur_2 as blur }

export declare interface BlurOptions {
    /**
     * Width of the blurring matrix, must be an odd integer.
     */
    width: number;
    /**
     * Height of the blurring matrix, must be an odd integer.
     */
    height: number;
    /**
     * Explicit how to handle the borders.
     * @default `'reflect101'`
     */
    borderType?: BorderType;
    /**
     * Value of the border if BorderType is 'constant'.
     * @default `0`
     */
    borderValue?: number;
    /**
     * Image to which to output.
     */
    out?: Image_2;
}

export declare interface Border {
    /**
     * Refers  to the roiID of the contiguous ROI.
     */
    connectedID: number;
    /**
     * Length of the border with connectedID.
     */
    length: number;
}

export declare type BorderInterpolationFunction = (column: number, row: number, channel: number, image: Image_2) => number;

export declare const BorderType: {
    readonly CONSTANT: "constant";
    readonly REPLICATE: "replicate";
    readonly REFLECT: "reflect";
    readonly WRAP: "wrap";
    readonly REFLECT_101: "reflect101";
};

export declare type BorderType = (typeof BorderType)[keyof typeof BorderType];

export declare function bottomHat(image: Image_2, options?: BottomHatOptions): Image_2;

export declare function bottomHat(image: Mask, options?: BottomHatOptions): Mask;

export declare interface BottomHatOptions {
    /**
     * 3x3 matrix. The kernel can only have ones and zeros.
     * Accessing a value: kernel[row][column].
     * @default `[[1, 1, 1], [1, 1, 1], [1, 1, 1]]`
     */
    kernel?: number[][];
    /**
     * Number of iterations of the algorithm.
     * @default `1`
     */
    iterations?: number;
}

export declare interface Brief {
    keypoints: OrientedFastKeypoint[];
    descriptors: BriefDescriptor[];
}

export declare type BriefDescriptor = Uint8Array;

export declare interface BruteForceMatchOptions {
    /**
     * Whether to sort the matches from best to worst.
     * @default `false`
     */
    sort?: boolean;
    /**
     * Number of best matches to return.
     * @default `source.length`
     */
    nbBestMatches?: number;
}

/**
 * Find the best match for each of the source descriptors using brute force matching.
 * @param source - Source descriptors.
 * @param destination - Destination descriptors.
 * @param options - Brute force amtch options.
 * @returns The best match for each source descriptor.
 */
export declare function bruteForceOneMatch(source: BriefDescriptor[], destination: BriefDescriptor[], options?: BruteForceMatchOptions): Match[];

/**
 * Apply Canny edge detection to an image.
 * @param image - Image to process.
 * @param options - Canny edge detection options.
 * @returns The processed image.
 */
export declare function cannyEdgeDetector(image: Image_2, options?: CannyEdgeOptions): Mask;

export declare interface CannyEdgeOptions {
    /**
     * Lower threshold of the gaussian blur (indicates the weak edges to discard).
     * @default `0.04`
     */
    lowThreshold?: number;
    /**
     * Higher threshold of the gaussian blur (indicates the strong edges to keep). Value must be between 0 and 1.
     * @default `0.1`
     */
    highThreshold?: number;
    /**
     * Standard deviation of the gaussian blur (sigma). Value must be between 0 and 1.
     * @default `{ sigma: 1 }`
     */
    gaussianBlurOptions?: GaussianBlurOptions;
    /**
     * Enable/ disable hysteresis steps.
     * @default `true`
     */
    hysteresis?: boolean;
    /**
     * Image to which the resulting image has to be put.
     */
    out?: Mask;
}

export declare const channelLabels: {
    readonly GREY: readonly ["Grey"];
    readonly GREYA: readonly ["Grey", "Alpha"];
    readonly RGB: readonly ["Red", "Green", "Blue"];
    readonly RGBA: readonly ["Red", "Green", "Blue", "Alpha"];
    readonly BINARY: readonly ["Mask"];
};

export declare type ClampFunction = (value: number) => number;

/**
 * Set the pixels connected to the border of the mask to zero. You can chose to allow corner connection of not with the `allowCorners` option.
 * @param mask - The mask to process.
 * @param options - Clear border options.
 * @returns The image with cleared borders.
 */
export declare function clearBorder(mask: Mask, options?: ClearBorderOptions): Mask;

export declare interface ClearBorderOptions {
    /**
     * Consider pixels connected by corners?
     * @default `false`
     */
    allowCorners?: boolean;
    /**
     * Image to which the resulting image has to be put.
     */
    out?: Mask;
    /**
     * Clear either white or black area touching the border.
     * In practice it will invert the color.
     * @default `'white'`
     */
    color?: 'white' | 'black';
}

declare function close_2(image: Image_2, options?: CloseOptions): Image_2;

declare function close_2(image: Mask, options?: CloseOptions): Mask;
export { close_2 as close }

export declare interface CloseOptions {
    /**
     * 3x3 matrix. The kernel can only have ones and zeros.
     * Accessing a value: kernel[row][column].
     * @default `[[1, 1, 1], [1, 1, 1], [1, 1, 1]]`
     */
    kernel?: number[][];
    /**
     * Number of iterations of the algorithm.
     * @default `1`
     */
    iterations?: number;
}

export declare const colorModels: Record<ImageColorModel, {
    components: number;
    alpha: boolean;
    channels: number;
}>;

/**
 * Generate an image with all the ROIs of various colors.
 * @param roiMapManager - The ROI map manager.
 * @param options - Color ROIs options.
 * @returns The colored image.
 */
export declare function colorRois(roiMapManager: RoiMapManager, options?: ColorRoisOptions): Image_2;

export declare interface ColorRoisOptions {
    /**
     * Define the color mode to use to color the ROIs.
     * @default `'binary'`
     */
    mode?: RoisColorMode;
    /**
     * Specify which ROIs to color.
     * @default `'bw'`
     */
    roiKind?: RoiKind;
}

/**
 * Compute the convolution of a value of a pixel in an image.
 * @param column - Column of the pixel.
 * @param row - Row of the pixel.
 * @param channel - Channel to process.
 * @param image - Image to process.
 * @param kernel - Kernel for the convolutions.
 * @param interpolateBorder - Function to interpolate the border pixels.
 * @param options - Compute convolution value options.
 * @returns The convoluted value.
 */
export declare function computeConvolutionValue(column: number, row: number, channel: number, image: Image_2, kernel: number[][], interpolateBorder: BorderInterpolationFunction, options?: ComputeConvolutionValueOptions): number;

export declare interface ComputeConvolutionValueOptions {
    /**
     * Specify wether the return value should not be clamped and rounded.
     */
    returnRawValue?: boolean;
    /**
     * If the value has to be clamped, specify the clamping function.
     */
    clamp?: ClampFunction;
}

/**
 * Compute the Mean Square Error (MSE) between two images.
 * The input images can have any number of channels.
 * @param image - First image.
 * @param otherImage - Second image.
 * @returns MSE of the two images.
 */
export declare function computeMse(image: Image_2, otherImage: Image_2): number;

/**
 * Compute the Peak signal-to-noise ratio (PSNR) between two images.
 * The larger the PSNR, the more similar the images.
 * @see {@link https://en.wikipedia.org/wiki/Peak_signal-to-noise_ratio}
 * @param image - First image.
 * @param otherImage - Second image.
 * @returns PSNR of the two images in decibels.
 */
export declare function computePsnr(image: Image_2, otherImage: Image_2): number;

/**
 * Compute the Root Mean Square Error (RMSE) between two images. It is just the square root of the MSE.
 * @see {@link https://en.wikipedia.org/wiki/Root-mean-square_deviation}
 * @param image - First image.
 * @param otherImage - Second image.
 * @returns RMSE of the two images.
 */
export declare function computeRmse(image: Image_2, otherImage: Image_2): number;

/**
 * Generate an array of ROIs based on an ROI map manager.
 * @param roiMapManager - Roi map manager to use.
 */
export declare function computeRois(roiMapManager: RoiMapManager): void;

/**
 * Compute threshold value for an image using the specified algorithm.
 * @param image - The grey image.
 * @param options - Threshold options.
 * @returns The threshold value for the image.
 */
export declare function computeThreshold(image: Image_2, options?: ThresholdOptionsAlgorithm): number;

/**
 * Convert Mask to GREY.
 * @param mask - Mask to convert.
 * @param newImage - Converted image.
 */
export declare function convertBinaryToGrey(mask: Mask, newImage: Image_2): void;

/**
 * Convert mask to RGB or RGBA.
 * @param mask - Mask to convert.
 * @param newImage - Converted image.
 */
export declare function convertBinaryToRgb(mask: Mask, newImage: Image_2): void;

/**
 * Convert the bit depth of an image.
 * @param image - Image to convert.
 * @param newBitDepth - Bit depth to convert to.
 * @param options - Convert bit depth options.
 * @returns Converted image.
 */
export declare function convertBitDepth(image: Image_2, newBitDepth: BitDepth, options?: ConvertBitDepthOptions): Image_2;

export declare interface ConvertBitDepthOptions {
    /**
     * Image to which to output.
     */
    out?: Image_2;
}

/**
 * Convert image to a different color model.
 * @param image - Image to convert.
 * @param colorModel - New color model.
 * @param options - Convert color options.
 * @returns The converted image.
 */
export declare function convertColor(image: Image_2 | Mask, colorModel: ImageColorModel, options?: ConvertColorOptions): Image_2;

export declare interface ConvertColorOptions {
    /**
     * Image to which to output.
     */
    out?: Image_2;
}

/**
 * Convex Hull polygon of a mask.
 */
export declare interface ConvexHull {
    /**
     * Vertices of the convex Hull in clockwise order.
     */
    points: Point[];
    /**
     * Perimeter of the convex Hull.
     */
    perimeter: number;
    /**
     * Surface of the convex Hull.
     */
    surface: number;
}

export declare interface ConvolutionOptions {
    /**
     * Specify how the borders should be handled.
     * @default `'reflect101'`
     */
    borderType?: BorderType;
    /**
     * Value of the border if BorderType is 'constant'.
     * @default `0`
     */
    borderValue?: number;
    /**
     * Whether the kernel should be normalized.
     * @default `false`
     */
    normalize?: boolean;
    /**
     * Image to which to output.
     */
    out?: Image_2;
}

/**
 * Copy alpha channel of source to dest.
 * @param source - Source image.
 * @param dest - Destination image.
 */
export declare function copyAlpha(source: Image_2, dest: Image_2): void;

export declare function copyTo(source: Image_2, target: Image_2, options?: CopyToOptions<Image_2>): Image_2;

export declare function copyTo(source: Mask, target: Mask, options?: CopyToOptions<Mask>): Mask;

export declare interface CopyToOptions<OutType> {
    /**
     * Origin for the crop relative to the top-left corner of the image.
     * @default `{row: 0, column: 0}`
     */
    origin?: Point;
    /**
     * Image to which to output.
     */
    out?: OutType;
}

/**
 * Corrects background from an image for baseline correction.
 * @param image - Image to subtract background from.
 * @param options - CorrectBackgroundOptions.
 * @returns Image with corrected baseline.
 */
export declare function correctBackground(image: Image_2, options: CorrectBackgroundOptions): Image_2;

export declare interface CorrectBackgroundOptions {
    /**
     * @param background - Points that are considered the background of an image.
     */
    background: Point[];
    /**
     * @param order - Order of regression function.
     * @default `2`
     */
    order?: number;
    /**
     * Checks if the image background is light or dark. If the background is
     *  light, the output image will be inverted.
     * @default `'light'`
     */
    backgroundKind?: 'dark' | 'light';
}

/**
 * Correct the colors in an image using the reference colors.
 * Algorithm is based on the paper "Color correction using improved linear regression algorithm".
 * DOI: 10.1109/ICTS.2015.7379874.
 * @param image - Image to process.
 * @param measuredColors - Colors from the image, which will be compared to the reference.
 * @param referenceColors - Reference colors.
 * @returns Image with the colors corrected.
 */
export declare function correctColor(image: Image_2, measuredColors: RgbColor[], referenceColors: RgbColor[]): Image_2;

export declare interface CreateFromOptions extends ImageOptions {
    width?: number;
    height?: number;
}

/**
 * Crop the input image to a desired size.
 * @param image - Image to crop.
 * @param [options] - Crop options.
 * @returns The new cropped image.
 * @example
 * var cropped = image.crop({
 *   row:20,
 *   column:100
 * });
 */
export declare function crop(image: Image_2, options?: CropOptions): Image_2;

/**
 * Crops the image based on the alpha channel
 * This removes lines and columns where the alpha channel is lower than a threshold value.
 * @param image - Image to process.
 * @param options - Crop alpha options.
 * @returns The cropped image.
 */
export declare function cropAlpha(image: Image_2, options?: CropAlphaOptions): Image_2;

export declare interface CropAlphaOptions {
    /**
     * Threshold from which rows and columns should be kept.
     */
    threshold?: number;
}

export declare interface CropOptions {
    /**
     * Origin of the crop relative to a parent image (top-left corner).
     * @default `{row: 0, column: 0}`
     */
    origin?: Point;
    /**
     * Specify the width of the cropped image.
     * @default `image.width`
     */
    width?: number;
    /**
     * Specify the width of the cropped image.
     * @default `image.height`
     */
    height?: number;
}

/**
 * Crop an oriented rectangle from an image.
 * If the rectangle's length or width are not an integers, its dimension is expanded in both directions such as the length and width are integers.
 * @param image - The input image
 * @param points - The points of the rectangle. Points must be circling around the rectangle (clockwise or anti-clockwise). The validity of the points passed is assumed and not checked.
 * @param options - Crop options, see {@link CropRectangleOptions}
 * @returns The cropped image. The orientation of the image is the one closest to the rectangle passed as input.
 */
export declare function cropRectangle(image: Image_2, points: Point[], options?: CropRectangleOptions): Image_2;

export declare type CropRectangleOptions = Omit<TransformOptions, 'width' | 'height' | 'inverse' | 'fullImage'>;

/**
 * Return the indices of pairs the keypoints that are mutually the best match.
 * This means that if B is the best match for A, A should be the best match for B.
 * The distance of the resulting matches is the maximum distance between the two.
 * @param srcDstMatches - Best matches computed from source do destination.
 * @param dstSrcMatches - Best matches computed from destination to source.
 * @returns The pairs of keypoints that are mutually the best match.
 */
export declare function crosscheck(srcDstMatches: Match[], dstSrcMatches: Match[]): Match[];

/**
 * Decode input data. Data format is automatically detected.
 * Possible formats: png, jpeg and tiff.
 * @param data - Data to decode.
 * @returns The decoded image.
 */
export declare function decode(data: ArrayBufferView): Image_2;

/**
 * Decode a jpeg. See the jpeg-js npm module.
 * @param buffer - The data to decode.
 * @returns The decoded image.
 */
export declare function decodeJpeg(buffer: Uint8Array): Image_2;

/**
 * Decode a PNG. See the fast-png npm module.
 * @param buffer - The data to decode.
 * @returns The decoded image.
 */
export declare function decodePng(buffer: Uint8Array): Image_2;

/**
 * Decode input data and create stack. Data format is automatically detected.
 * Possible formats: tiff.
 * @param data - Data to decode.
 * @returns The decoded image.
 */
export declare function decodeStack(data: ArrayBufferView): Stack;

/**
 * Decode a TIFF. See the tiff module.
 * @param buffer - The data to decode.
 * @returns The decoded image.
 */
export declare function decodeTiff(buffer: Uint8Array): Image_2;

export declare const defaultPng: EncodeOptionsPng;

export declare const DerivativeFilter: {
    readonly SOBEL: "sobel";
    readonly SCHARR: "scharr";
    readonly PREWITT: "prewitt";
};

export declare type DerivativeFilter = (typeof DerivativeFilter)[keyof typeof DerivativeFilter];

/**
 * Apply a derivative filter to an image.
 * @param image - Image to process.
 * @param options - Derivative filter options.
 * @returns The processed image.
 */
export declare function derivativeFilter(image: Image_2, options?: DerivativeFilterOptions): Image_2;

export declare interface DerivativeFilterOptions {
    /**
     * Algorithm to use for the derivative filter.
     * @default `SOBEL`
     */
    filter?: DerivativeFilter;
    /**
     * Specify how the borders should be handled.
     * @default `'replicate'`
     */
    borderType?: BorderType;
    /**
     * Value of the border if BorderType is 'constant'.
     * @default `0`
     */
    borderValue?: number;
    /**
     * Specify the bit depth of the resulting image.
     * @default `image.bitDepth`
     */
    bitDepth?: BitDepth;
}

export declare function dilate(image: Image_2, options?: DilateOptions): Image_2;

export declare function dilate(image: Mask, options?: DilateOptions): Mask;

export declare interface DilateOptions {
    /**
     * Matrix with odd dimensions (e.g. 1 by 3). The kernel can only have ones and zeros.
     * Accessing a value: kernel[row][column].
     * @default `[[1, 1, 1], [1, 1, 1], [1, 1, 1]]`
     */
    kernel?: number[][];
    /**
     * Number of iterations of the algorithm.
     *  @default `1`
     */
    iterations?: number;
}

/**
 * Apply a direct convolution on an image using the specified kernel. The convolution corresponds of a weighted average of the surrounding pixels, the weights being defined in the kernel.
 * @param image - The image to process.
 * @param kernel - Kernel to use for the convolution. Should be a 2D matrix with odd number of rows and columns.
 * @param options - Convolution options.
 * @returns The convoluted image.
 */
export declare function directConvolution(image: Image_2, kernel: number[][], options?: ConvolutionOptions): Image_2;

/**
 *
 * Divides image pixels by a certain value.
 * @param image - image to which division will be applied.
 * @param value - Value by which each pixel will be divided.
 * @param options - Divide options
 * @returns image.
 */
export declare function divide(image: Image_2, value: number, options?: DivideOptions): Image_2;

export declare interface DivideOptions {
    /**
     * Channels where value will be divided.
     * @default all channels
     */
    channels?: number[];
    /**
     * Image to which the resulting image has to be put.
     */
    out?: Image_2;
}

/**
 * Draw a circle defined by center and radius.
 * @param image - Image to process.
 * @param center - Circle center point.
 * @param radius - Circle radius.
 * @param options - Draw circle options.
 * @returns The original drawn image.
 */
export declare function drawCircleOnImage(image: Image_2, center: Point, radius: number, options?: DrawCircleOnImageOptions): Image_2;

export declare interface DrawCircleOnImageOptions {
    /**
     * Circle border color - An array of numerical values, one for each channel of the image. If less values are defined than there are channels in the image, the remaining channels will be set to 0.
     * @default A black pixel.
     */
    strokeColor?: number[];
    /**
     * Circle fill color - An array of numerical values, one for each channel of the image. If less values are defined than there are channels in the image, the remaining channels will be set to 0.
     *
     */
    fillColor?: number[];
    /**
     * Image to which the resulting image has to be put.
     */
    out?: Image_2;
}

export declare function drawKeypoints(image: Image_2, keypoints: FastKeypoint[], options?: DrawKeypointsOptions): Image_2;

export declare function drawKeypoints(image: Image_2, keypoints: OrientedFastKeypoint[], options?: DrawOrientedKeypointsOptions): Image_2;

export declare interface DrawKeypointsOptions {
    /**
     * Origin of the keypoints in the image.
     * @default `{row: 0, column: 0}`
     */
    origin?: Point;
    /**
     * Markers size in pixels.
     * @default `10`
     */
    markerSize?: number;
    /**
     * Keypoint's color - An array of numerical values, one for each channel of the image. If less values are defined than there are channels in the image, the remaining channels will be set to 0.
     * @default `[255,0,0]`
     */
    strokeColor?: number[];
    /**
     * Whether to fill the markers.
     * @default `false`
     */
    fill?: boolean;
    /**
     * Whether the score of the keypoints should be reflected in their color.
     * @default `false`
     */
    showScore?: boolean;
    /**
     * Maximal number of matches with smallest distance to draw.
     * @default `keypoints.length`
     */
    maxNbKeypoints?: number;
    /**
     * Image to which the resulting image has to be put.
     */
    out?: Image_2;
    /**
     * Options for the coloring of the keypoints depending on their score (useful if showScore = true).
     */
    showScoreOptions?: GetColorsOptions;
}

/**
 * Draw a line defined by two points onto an image.
 * @param image - Image to process.
 * @param from - Line starting point.
 * @param to - Line ending point.
 * @param options - Draw Line options.
 * @returns The mask with the line drawing.
 */
export declare function drawLineOnImage(image: Image_2, from: Point, to: Point, options?: DrawLineOnImageOptions): Image_2;

export declare interface DrawLineOnImageOptions {
    /**
     * Color of the line - An array of numerical values, one for each channel of the image. If less values are defined than there are channels in the image, the remaining channels will be set to 0.
     * @default A black pixel.
     */
    strokeColor?: number[];
    /**
     * Origin of the line relative to a parent image (top-left corner).
     * @default `{row: 0, column: 0}`
     */
    origin?: Point;
    /**
     * Image to which the resulting image has to be put.
     */
    out?: Image_2;
}

/**
 * Draw a line defined by two points onto a mask.
 * @param mask - Mask to process.
 * @param from - Line starting point.
 * @param to - Line ending point.
 * @param options - Draw Line options.
 * @returns The mask with the line drawing.
 */
export declare function drawLineOnMask(mask: Mask, from: Point, to: Point, options?: DrawLineOnMaskOptions): Mask;

export declare interface DrawLineOnMaskOptions {
    /**
     * Origin of the line relative to a parent image (top-left corner).
     * @default `{row: 0, column: 0}`
     */
    origin?: Point;
    /**
     * Mask to which the result has to be put.
     */
    out?: Mask;
}

/**
 * Draw a marker on the image.
 * @param image - Image to process.
 * @param point - Marker center point.
 * @param options - Draw marker options.
 * @returns The image with the marker drawing.
 */
export declare function drawMarker(image: Image_2, point: Point, options: DrawMarkerOptions): Image_2;

export declare interface DrawMarkerOptions {
    /**
     * Marker size, Odd number greater than 1.
     * @default `1`
     */
    size?: number;
    /**
     * Marker shape.
     * @default `'cross'`
     */
    shape?: 'circle' | 'triangle' | 'cross' | 'square';
    /**
     * Circle border color - An array of numerical values, one for each channel of the image. If less values are defined than there are channels in the image, the remaining channels will be set to 0.
     */
    fillColor?: number[];
    /**
     * Circle border color - An array of numerical values, one for each channel of the image. If less values are defined than there are channels in the image, the remaining channels will be set to 0.
     * @default A black pixel.
     */
    strokeColor?: number[];
    /**
     * Image to which the resulting image has to be put.
     */
    out?: Image_2;
}

/**
 * Draw markers on the image.
 * @param image - Image to process.
 * @param points - Markers center points.
 * @param options - Draw marker options.
 * @returns The image with the markers drawing.
 */
export declare function drawMarkers(image: Image_2, points: Point[], options?: DrawMarkerOptions): Image_2;

/**
 * Draw the the matches between two images on their montage.
 * @param montage - The montage of two images to match.
 * @param matches - The matches between source and destination.
 * @param sourceKeypoints - Source keypoints.
 * @param destinationKeypoints - Destination keypoints.
 * @param options - Draw matches options.
 * @returns The comparison image.
 */
export declare function drawMatches(montage: Montage, matches: Match[], sourceKeypoints: FastKeypoint[], destinationKeypoints: FastKeypoint[], options?: DrawMatchesOptions): Image_2;

export declare interface DrawMatchesOptions {
    /**
     * Circles diameter in pixels.
     * @default `10`
     */
    circleDiameter?: number;
    /**
     * Annotations color - An array of numerical values, one for each channel of the image. If less values are defined than there are channels in the image, the remaining channels will be set to 0.
     * @default `[255,0,0]`
     */
    strokeColor?: number[];
    /**
     * Whether the matches should be colored depending on the distance.
     * @default `false`
     */
    showDistance?: boolean;
    /**
     * Options for the coloring of the matches depending on their distance (useful if showDistance = true).
     */
    showDistanceOptions?: GetColorsOptions;
    /**
     * Maximal number of keypoints with best score to draw.
     * @default `matches.length`
     */
    maxNbMatches?: number;
}

export declare interface DrawOrientedKeypointsOptions extends DrawKeypointsOptions {
    /**
     * Show the orientation of the keypoints.
     * @default `false`
     */
    showOrientation?: boolean;
}

export declare function drawPoints(image: Image_2, points: Point[], options?: DrawPointsOptions): Image_2;

export declare function drawPoints(image: Mask, points: Point[], options?: DrawPointsOptions): Mask;

export declare interface DrawPointsOptions {
    /**
     * Color of the points - An array of numerical values, one for each channel of the image. If less values are defined than there are channels in the image, the remaining channels will be set to 0.
     * @default A black pixel.
     */
    color?: number[];
    /**
     * Origin of the points relative to a parent image (top-left corner).
     * @default `{row: 0, column: 0}`
     */
    origin?: Point;
    /**
     * Image to which the resulting image has to be put.
     */
    out?: Image_2 | Mask;
}

/**
 * Draw a polygon defined by an array of points onto an image.
 * @param image - Image to process.
 * @param points - Polygon vertices.
 * @param options - Draw Line options.
 * @returns The image with the polygon drawing.
 */
export declare function drawPolygonOnImage(image: Image_2, points: Point[], options?: DrawPolygonOnImageOptions): Image_2;

export declare interface DrawPolygonOnImageOptions extends DrawPolylineOnImageOptions {
    /**
     * Fill color - An array of numerical values, one for each channel of the image. If less values are defined than there are channels in the image, the remaining channels will be set to 0.
     * @default A black pixel.
     */
    fillColor?: number[];
    /**
     * Origin of the rectangle relative to a parent image (top-left corner).
     * @default `{row: 0, column: 0}`
     */
    origin?: Point;
}

/**
 * Draw a polygon defined by an array of points on a mask.
 * @param mask - Mask to process.
 * @param points - Polygon vertices.
 * @param options - Draw Line options.
 * @returns The mask with the polygon drawing.
 */
export declare function drawPolygonOnMask(mask: Mask, points: Point[], options?: DrawPolygonOnMaskOptions): Mask;

export declare interface DrawPolygonOnMaskOptions extends DrawPolylineOnMaskOptions {
    /**
     * Fill polygon.
     */
    filled?: boolean;
    /**
     * Origin of the rectangle relative to a parent image (top-left corner).
     * @default `{row: 0, column: 0}`
     */
    origin?: Point;
}

/**
 * Draw a polyline defined by an array of points on an image.
 * @param image - Image to process.
 * @param points - Polyline array of points.
 * @param options - Draw polyline options.
 * @returns The image with the polyline drawing.
 */
export declare function drawPolylineOnImage(image: Image_2, points: Point[], options?: DrawPolylineOnImageOptions): Image_2;

export declare interface DrawPolylineOnImageOptions {
    /**
     * Line color - An array of numerical values, one for each channel of the image. If less values are defined than there are channels in the image, the remaining channels will be set to 0.
     * @default A black pixel.
     */
    strokeColor?: number[];
    /**
     * Origin of the rectangle relative to a parent image (top-left corner).
     * @default `{row: 0, column: 0}`
     */
    origin?: Point;
    /**
     * Image to which the resulting image has to be put.
     */
    out?: Image_2;
}

/**
 * Draw a polyline defined by an array of points on an image.
 * @param mask - Mask to process.
 * @param points - Polyline array of points.
 * @param options - Draw polyline options.
 * @returns The mask with the polyline drawing.
 */
export declare function drawPolylineOnMask(mask: Mask, points: Point[], options?: DrawPolylineOnMaskOptions): Mask;

export declare interface DrawPolylineOnMaskOptions {
    /**
     * Origin of the rectangle relative to a parent image (top-left corner).
     * @default `{row: 0, column: 0}`
     */
    origin?: Point;
    /**
     * Mask to which the resulting image has to be put.
     */
    out?: Mask;
}

export declare function drawRectangle(image: Image_2, options?: DrawRectangleOptions<Image_2>): Image_2;

export declare function drawRectangle(image: Mask, options?: DrawRectangleOptions<Mask>): Mask;

export declare interface DrawRectangleOptions<OutType> {
    /**
     * Origin of the rectangle relative to a parent image (top-left corner).
     * @default `{row: 0, column: 0}`
     */
    origin?: Point;
    /**
     * Specify the width of the rectangle.
     * @default `image.width`
     */
    width?: number;
    /**
     * Specify the width of the rectangle.
     * @default `image.height`
     */
    height?: number;
    /**
     * Color of the rectangle's border - An array of numerical values, one for each channel of the image. If less values are defined than there are channels in the image, the remaining channels will be set to 0.
     * @default A black pixel.
     */
    strokeColor?: number[];
    /**
     * Rectangle fill color - An array of numerical values, one for each channel of the image. If less values are defined than there are channels in the image, the remaining channels will be set to 0.
     *
     */
    fillColor?: number[];
    /**
     * Image to which the resulting image has to be put.
     */
    out?: OutType;
}

export declare interface Ellipse {
    center: {
        column: number;
        row: number;
    };
    majorAxis: {
        points: [Point, Point];
        length: number;
        angle: number;
    };
    minorAxis: {
        points: [Point, Point];
        length: number;
        angle: number;
    };
    surface: number;
}

/**
 * Encodes the image to the specified format
 * @param image - Image to encode.
 * @param options - Format and options passed to the encoder.
 * @returns The encoded image.
 */
export declare function encode(image: Image_2 | Mask, options?: EncodeOptionsBmp | EncodeOptionsPng | EncodeOptionsJpeg): Uint8Array;

/**
 * Converts image into Data URL string.
 * @param image - Image to get base64 encoding from.
 * @param options - Encoding options.
 * @returns base64 string.
 */
export declare function encodeDataURL(image: Image_2, options?: EncodeOptionsBmp | EncodeOptionsPng | EncodeOptionsJpeg): string;

/**
 * Creates a JPEG buffer from an image.
 * @param image - The image instance.
 * @param options - JPEG encoding options.
 * @returns The buffer.
 */
export declare function encodeJpeg(image: Image_2 | Mask, options?: EncodeJpegOptions): Uint8Array;

export declare interface EncodeJpegOptions {
    /**
     * Defines jpeg quality. Integer value between 1 and 100%, 100% being the best quality.
     * @default `50`
     */
    quality?: number;
}

export declare interface EncodeOptionsBmp {
    format: 'bmp';
}

export declare interface EncodeOptionsJpeg {
    format: 'jpg' | 'jpeg';
    encoderOptions?: EncodeJpegOptions;
}

export declare interface EncodeOptionsPng {
    format: 'png';
    encoderOptions?: EncodePngOptions;
}

/**
 * Creates a PNG buffer from an image.
 * @param image - The image instance.
 * @param options - PNG encoding options.
 * @returns The buffer.
 */
export declare function encodePng(image: Image_2 | Mask, options?: EncodePngOptions): Uint8Array;

export declare type EncodePngOptions = PngEncoderOptions;

export declare function erode(image: Image_2, options?: ErodeOptions): Image_2;

export declare function erode(image: Mask, options?: ErodeOptions): Mask;

export declare interface ErodeOptions {
    /**
     * Matrix with odd dimensions (e.g. 1 by 3). The kernel can only have ones and zeros.
     * Accessing a value: kernel[row][column].
     * @default `[[1, 1, 1], [1, 1, 1], [1, 1, 1]]`
     */
    kernel?: number[][];
    /**
     * Number of iterations of the algorithm.
     * @default `1`
     */
    iterations?: number;
}

/**
 * Extend the borders of an image according to the given border type.
 * @param image - Image to extend.
 * @param options - Options.
 * @returns A copy of the image with extended borders.
 */
export declare function extendBorders(image: Image_2, options: ExtendBordersOptions): Image_2;

export declare interface ExtendBordersOptions {
    /**
     * Left and right border thickness.
     */
    horizontal: number;
    /**
     *Top and bottom border thickness.
     */
    vertical: number;
    /**
     * Specify how the borders should be handled.
     * @default `'reflect101'`
     */
    borderType?: BorderType;
    /**
     * Value of the border if BorderType is 'constant'.
     * @default `0`
     */
    borderValue?: number;
}

/**
 * Extract the pixels of an image, as specified in a mask.
 * @param image - The image to process.
 * @param mask - The mask defining which pixels to keep.
 * @param options - Extract options.
 * @returns The extracted image.
 */
export declare function extract(image: Image_2, mask: Mask, options?: ExtractOptions): Image_2;

export declare interface ExtractOptions {
    /**
     * Origin of the ROI relative to a parent image (top-left corner).
     * @default `{row: 0, column: 0}`
     */
    origin?: Point;
}

export declare interface ExtremaOptions {
    /**
     * Chooses what kind of extremum to compute.
     * @default `'maximum'`
     */
    kind?: 'minimum' | 'maximum';
    /**
     * Uses mask to check if a point belongs to a ROI or not
     * @default `undefined`
     */
    mask?: Mask;
    /**
     * Chooses what kind of coverage algorithm to use to compute the extremum.
     * @default `'star'`
     */
    algorithm?: 'cross' | 'square' | 'star';
    /**
     * Maximum number of points that can be equal to the extremum
     * @default `2`
     */
    maxEquals?: number;
}

export declare interface FastKeypoint {
    /**
     * Location of the keypoint in the image.
     */
    origin: Point;
    /**
     * Score of the keypoint, the bigger it is, the better the feature.
     * It is the criteria used for the non-maximal suppression.
     */
    score: number;
}

export declare interface Feret {
    /**
     * Smaller Feret diameter.
     */
    minDiameter: FeretDiameter;
    /**
     * Bigger Feret diameter.
     */
    maxDiameter: FeretDiameter;
    /**
     * Ratio between the smaller and the bigger diameter.
     * Expresses how elongated the shape is. This is a value between 0 and 1.
     */
    aspectRatio: number;
}

export declare interface FeretDiameter {
    /**
     * Start and end point of the Feret diameter.
     */
    points: Point[];
    /**
     * Length of the diameter.
     */
    length: number;
    /**
     * Angle between the diameter and a horizontal line in degrees.
     */
    angle: number;
    /**
     * Calliper lines that pass by endpoints of Feret diameters.
     */
    calliperLines: [[Point, Point], [Point, Point]];
}

/**
 * Fetches image URL and decodes it.
 * @param dataUrl - Image URL.
 * @returns decoded image data.
 */
export declare function fetchURL(dataUrl: string): Promise<Image_2>;

/**
 * Apply a flip filter to an image.
 * @param image - Image to process.
 * @param options - Flip options.
 * @returns - The processed image.
 */
export declare function flip(image: Image_2, options?: FlipOptions): Image_2;

export declare interface FlipOptions {
    /**
     * Image to which the resulting image has to be put.
     * @default `'horizontal'`
     */
    axis?: 'horizontal' | 'vertical' | 'both';
    /**
     * Image to which the resulting image has to be put.
     */
    out?: Image_2;
}

/**
 * Apply a flood fill algorithm to an image.
 * @param mask - Mask to process.
 * @param options - Flood fill options.
 * @returns The filled mask.
 */
export declare function floodFill(mask: Mask, options?: FloodFillOptions): Mask;

export declare interface FloodFillOptions {
    /**
     * Origin for the algorithm relative to the top-left corner of the image.
     * @default `{row: 0, column: 0}`
     */
    origin?: Point;
    /**
     * Consider pixels connected by corners?
     * @default `false`
     */
    allowCorners?: boolean;
    /**
     * Specify the output image.
     */
    out?: Mask;
}

/**
 * Extract the ROIs of an image.
 * @param mask - Mask to extract the ROIs from.
 * @param options - From mask options.
 * @returns The corresponding ROI manager.
 */
export declare function fromMask(mask: Mask, options?: FromMaskOptions): RoiMapManager;

export declare interface FromMaskOptions {
    /**
     * Consider pixels connected by corners as same ROI?
     * @default `false`
     */
    allowCorners?: boolean;
}

/**
 * Apply a gaussian filter to an image.
 * @param image - Image to blur.
 * @param options - Gaussian blur options.
 * @returns The blurred image.
 */
export declare function gaussianBlur(image: Image_2, options: GaussianBlurOptions): Image_2;

declare interface GaussianBlurBaseOptions {
    /**
     * Specify how the borders should be handled.
     * @default `'reflect101'`
     */
    borderType?: BorderType;
    /**
     * Image to which the resulting image has to be put.
     */
    out?: Image_2;
}

export declare type GaussianBlurOptions = GaussianBlurSigmaOptions | GaussianBlurXYOptions;

export declare interface GaussianBlurSigmaOptions extends GaussianBlurBaseOptions {
    /**
     * The standard deviation. Specifies the width of the gaussian function in the case where it is the same for x and y.
     */
    sigma: number;
    /**
     * Size of the kernel.
     * @default `2 * Math.ceil(2 * sigma) + 1`
     */
    size?: number;
}

export declare interface GaussianBlurXYOptions extends GaussianBlurBaseOptions {
    /**
     * The standard deviation for the x axis. Specifies the width of the gaussian function along x.
     */
    sigmaX: number;
    /**
     * The standard deviation for the y axis. Specifies the width of the gaussian function along y.
     */
    sigmaY: number;
    /**
     * Size of the X axis kernel.
     * @default `2 * Math.ceil(2 * sigmaX) + 1`
     */
    sizeX?: number;
    /**
     * Size of the Y axis kernel.
     * @default `2 * Math.ceil(2 * sigmaY) + 1`
     */
    sizeY?: number;
}

/**
 * Get the affine transformation from the source to the destination image.
 * @param source - Source image. Should be the image to align on the reference image.
 * It can have an additional margin, specified in the options.
 * @param destination - Destination image. Should be the reference image.
 * @param options - Get destination translation options.
 * @returns The affine transformation from source to destination image.
 */
export declare function getAffineTransform(source: Image_2, destination: Image_2, options?: GetAffineTransformOptions): GetAffineTransformResult;

export declare interface GetAffineTransformOptions {
    /**
     * @default `31`
     */
    centroidPatchDiameter?: number;
    /**
     * @default `10`
     */
    bestKeypointRadius?: number;
    /**
     * Should only the crossckeck matches be considered.
     * @default `true`
     */
    crosscheck?: boolean;
    /**
     * Should the contrast of the images be enhanced before feature matching.
     * @default `true`
     */
    enhanceContrast?: boolean;
    /**
     * Origin of the destination image relative to the top-left corner of the source image.
     * Roughly indicates the position of the destination image in the source image. Is used
     * to filter matches by distance as well as to define a subarea of the source image to
     * use for contrast enhancement.
     * @default `{ column: 0, row: 0 }`
     */
    destinationOrigin?: Point;
    /**
     * Max number of iterations of the ransac algorithm.
     */
    maxRansacNbIterations?: number;
    /**
     * Save images with matches for debugging.
     * @default `false`
     */
    debug?: boolean;
    /**
     * Path of the debug image.
     * @default `${import.meta.dirname}/montage.png`
     */
    debugImagePath?: string;
}

export declare interface GetAffineTransformResult {
    /**
     * Affine transformation from source to destination.
     */
    transform: AffineTransform;
    stats: {
        /**
         * Number of matches of feature matching between source and destination.
         * The bigger this number is, the better.
         */
        nbMatches: number;
        /**
         * Number of inliers resulting from the ransac algorithm.
         */
        nbInliers: number;
        /**
         * Number of iterations of the RANSAC algorithm.
         */
        nbRansacIterations: number;
        /**
         * Number of source keypoints used for matching.
         */
        nbSourceKeypoints: number;
        /**
         * Number of destination keypoints used for matching.
         */
        nbDestinationKeypoints: number;
    };
}

/**
 * Return the best keypoints within the given radius in pixels.
 * @param keypoints - Keypoints to process.
 * @param radius - Minimum distance in pixels between two keypoints.
 * @returns The filtered keypoints.
 */
export declare function getBestKeypointsInRadius(keypoints: OrientedFastKeypoint[], radius?: number): OrientedFastKeypoint[];

/**
 * Return an array with the coordinates of the pixels that are on the border of the ROI.
 * The reference is the top-left corner of the ROI.
 * @param roi - ROI to process.
 * @param options - Get border points options.
 * @returns The array of border pixels.
 */
export declare function getBorderPoints(roi: Roi, options?: GetBorderPointsOptions): Point[];

export declare interface GetBorderPointsOptions {
    /**
     * Should the inner borders be returned too?
     * @default `false`
     */
    innerBorders?: boolean;
    /**
     * Consider pixels connected by corners?
     * @default `false`
     */
    allowCorners?: boolean;
}

/**
 * Generate the rBRIEF descriptors for the desired keypoints of an image.
 * The rBRIEF descriptors are presented in these articles:
 * - ORB article: DOI: 10.1109/ICCV.2011.6126544
 * - rBRIEF article: DOI: 10.1007/978-3-642-15561-1_56.
 * @param image - Source image of the keypoints.
 * @param keypoints - Keypoints for which the descriptors are wanted.
 * @param options - Get rotated BRIEF descriptors options.
 * @returns The descriptors for the given keypoints.
 */
export declare function getBriefDescriptors(image: Image_2, keypoints: OrientedFastKeypoint[], options?: GetBriefDescriptorsOptions): Brief;

export declare interface GetBriefDescriptorsOptions {
    /**
     * Options to smooth the image patch before comparing pairs of points.
     * Default values are the ones recommended in the original BRIEF article.
     * DOI: https://doi.org/10.1007/978-3-642-15561-1_56.
     */
    smoothingOptions?: GaussianBlurSigmaOptions;
    /**
     * Options to modify the gaussian distribution used to generate the points to compare.
     */
    pointsDistributionOptions?: Omit<GetGaussianPointsOptions, 'nbPoints'>;
    /**
     * Size of the patch around the keypoint used to compute the descriptor.
     * @default `31`
     */
    patchSize?: number;
    /**
     * Number of bits of the final descriptor. Typically a power or 2: 128, 256, 512.
     * @default `256`
     */
    descriptorLength?: number;
}

export declare interface GetColorsOptions {
    /**
     * Number of shades to generate.
     * @default `6`
     */
    nbShades?: number;
    /**
     * Factor between 0 and 1 by which to multiply the maximal value of the color to obtain the minimum value.
     * @default `0.2`
     */
    minValueFactor?: number;
}

/**
 * Get the crosscheck matches from the source and destination descriptors.
 * @param source - Source descriptors.
 * @param destination - Destination descriptors.
 * @returns The array of crossckeck matches.
 */
export declare function getCrosscheckMatches(source: BriefDescriptor[], destination: BriefDescriptor[]): Match[];

/**
 * Return a 0 to 3 value indicating the four main directions (horizontal, upward diagonal, vertical, downward diagonal).
 * @param x - The x coordinate.
 * @param y - The y coordinate.
 * @returns The direction as a 0 to 4 value.
 */
export declare function getDirection(x: number, y: number): number;

/**
 * Checks the surrounding values of a point. If they are all bigger or smaller than the pixel in question then this point is considered an extremum.
 * @param image - Image to find extrema from.
 * @param options - ExtremaOptions
 * @returns Array of Points.
 */
export declare function getExtrema(image: Image_2, options: ExtremaOptions): Point[];

/**
 * Find the features in a GREY image according to the FAST (Features from Accelerated Segment Test) algorithm.
 * Based on the paper Machine Learning for High-Speed Corner Detection.
 * DOI: https://doi.org/10.1007/11744023_34.
 * @param image - The image to process.
 * @param options - Get FAST keypoints options.
 * @returns The FAST keypoints.
 */
export declare function getFastKeypoints(image: Image_2, options?: GetFastKeypointsOptions): FastKeypoint[];

export declare interface GetFastKeypointsOptions extends IsFastKeypointOptions {
    /**
     * Maximum number of features to return.
     * @default `500`
     */
    maxNbFeatures?: number;
    /**
     * Whether to apply non-max suppression to the keypoints.
     * This removes all keypoints which
     * don't have the highest value within the adjacent keypoints.
     * @default `true`
     */
    nonMaxSuppression?: boolean;
    /**
     * Radius of the circle used for the algorithm.
     * @default `3`
     */
    fastRadius?: number;
    /**
     * Algorithm to use to compute corners score.
     * @default `'FAST'`
     */
    scoreAlgorithm?: 'HARRIS' | 'FAST';
    /**
     * Options for the Harris score computation.
     */
    harrisScoreOptions?: GetHarrisScoreOptions;
}

export declare interface GetGaussianPointsOptions {
    /**
     * Number of points to generate.
     * @default `1024`
     */
    nbPoints?: number;
    /**
     * Seed of the gaussian distribution for the x coordinates.
     * @default `0`
     */
    xSeed?: number;
    /**
     * Seed of the gaussian distribution for the y coordinates.
     * @default `1`
     */
    ySeed?: number;
    /**
     * The standard deviation for the gaussian distribution.
     */
    sigma?: number;
}

export declare interface GetHarrisScoreOptions {
    /**
     * Size of the window to compute the Harris score.
     * Should be an odd number so that the window can be centered on the corner.
     * @default `7`
     */
    windowSize?: number;
    /**
     * Constant for the score computation. Should be between 0.04 and 0.06 (empirical values). This consant is commonly called k.
     * @default `0.04`
     */
    harrisConstant?: number;
}

/**
 * Create image from a single IFD.
 * @param ifd - The IFD.
 * @returns The decoded image.
 */
export declare function getImageFromIFD(ifd: TiffIfd): Image_2;

/**
 * Compute the intensity centroid of an image for each channel relatively to the center of the image.
 * Original article: {@link https://doi.org/10.1006/cviu.1998.0719}.
 * @see {@link https://en.wikipedia.org/wiki/Image_moment}
 * @param image - Image to process.
 * @returns The intensity centroid of each channel of the image.
 */
export declare function getIntensityCentroid(image: Image_2): Point[];

/**
 * Generate a mask of an ROI.
 * @param roi - The ROI to generate a mask for.
 * @param options - Get mask options.
 * @returns The ROI mask.
 */
export declare function getMask(roi: Roi, options?: GetMaskOptions): Mask;

export declare interface GetMaskOptions {
    /**
     * Should the ROI holes be filled in the resulting mask?
     * @default `false`
     */
    solidFill?: boolean;
}

/**
 * Find the oriented FAST features in a GREY image.
 * How to add orientation to FAST is described in: http://www.gwylab.com/download/ORB_2012.pdf
 * Basically, the intensity centroid of the window around the corner is computed and the
 * orientation is given by the vector from the center to the intensity centroid.
 * @param image - The image to process.
 * @param options - Get oriented FAST keypoints options.
 * @returns The oriented FAST keypoints.
 */
export declare function getOrientedFastKeypoints(image: Image_2, options?: GetOrientedFastKeypointsOptions): OrientedFastKeypoint[];

export declare interface GetOrientedFastKeypointsOptions extends GetFastKeypointsOptions {
    /**
     * Diameter of the circle used for compotuation of the intensity centroid.
     * @default `7`
     */
    centroidPatchDiameter?: number;
}

/**
 * Computes a perspective transformation matrix to rectify a quadrilateral region into a rectangle.
 *
 * This function takes four corner points of a quadrilateral (e.g., a document photographed at an angle) and calculates the transformation matrix needed to "unwarp" it into a rectangular image.
 * The output dimensions can be specified or calculated automatically based on the input geometry.
 * @param pts - 4 reference corners.
 * @param options - PerspectiveWarpOptions.
 * @returns - Matrix from 4 points.
 */
export declare function getPerspectiveWarp(pts: Point[], options?: GetPerspectiveWarpOptions): GetPerspectiveWarpData;

/**
 * Returns result matrix along with vertical and horizontal dimensions for the rectangular image.
 */
export declare type GetPerspectiveWarpData = Required<GetPerspectiveWarpOptions> & {
    matrix: number[][];
};

/**
 * Options for getPerspectiveWarp function.
 */
export declare interface GetPerspectiveWarpOptions {
    /**
     * The horizontal dimension (in pixels) of the final rectified rectangular image.
     */
    width?: number;
    /**
     * The vertical dimension (in pixels) of the final rectified rectangular image.
     */
    height?: number;
}

/**
 * Compute the third order variables for the regression from an RGB color.
 * @param r - Red component.
 * @param g - Green component.
 * @param b - Blue component.
 * @param maxValue - Maximal acceptable value for the image to process.
 * @returns The variables for the multivariate linear regression.
 */
export declare function getRegressionVariables(r: number, g: number, b: number, maxValue: number): number[];

/**
 * Return an array of ROIs matching the options.
 * @param roiMapManager - The ROI map manager containing the ROIs.
 * @param options - Get ROIs options.
 * @returns The array of ROIs.
 */
export declare function getRois(roiMapManager: RoiMapManager, options?: GetRoisOptions): Roi[];

export declare interface GetRoisOptions {
    /**
     * Minimal surface of the ROIs to keep.
     * @default `0`
     */
    minSurface?: number;
    /**
     * Maximal surface of the ROIs to keep.
     * @default `Number.MAX_SAFE_INTEGER`
     */
    maxSurface?: number;
    /**
     * Kind of ROIs to keep.
     * @default `'white'`
     */
    kind?: RoiKind;
}

/**
 * Apply a gradient filter to an image.
 * @param image - The image to process.
 * @param options - Gradient filter options.
 * @returns The gradient image.
 */
export declare function gradientFilter(image: Image_2, options: GradientFilterOptions): Image_2;

export declare interface GradientFilterBaseOptions {
    /**
     * Specify how the borders should be handled.
     * @default `'replicate'`
     */
    borderType?: BorderType;
    /**
     * Value of the border if BorderType is 'constant'.
     * @default `0`
     */
    borderValue?: number;
    /**
     * Specify the bit depth of the resulting image.
     * @default `image.bitDepth`
     */
    bitDepth?: BitDepth;
}

export declare type GradientFilterOptions = GradientFilterXOptions | GradientFilterYOptions | GradientFilterXYOptions;

export declare interface GradientFilterXOptions extends GradientFilterBaseOptions {
    /**
     * Kernel along x axis.
     */
    kernelX: number[][];
}

export declare interface GradientFilterXYOptions extends GradientFilterBaseOptions {
    /**
     * Kernel along x axis.
     */
    kernelX: number[][];
    /**
     * Kernel along y axis.
     */
    kernelY: number[][];
}

export declare interface GradientFilterYOptions extends GradientFilterBaseOptions {
    /**
     * Kernel along y axis.
     */
    kernelY: number[][];
}

/**
 * Convert the current image to grayscale.
 * The source image has to be RGB or RGBA.
 * If there is an alpha channel you have to specify what to do:
 * - keepAlpha :  keep the alpha channel, you will get a GREYA image.
 * - mergeAlpha : multiply each pixel of the image by the alpha, you will get a GREY image.
 * @param image - Original color image to convert to grey.
 * @param options - The grey conversion options.
 * @returns The resulting grey image.
 */
export declare function grey(image: Image_2, options?: GreyOptions): Image_2;

export declare const GreyAlgorithm: {
    readonly LUMA_709: "luma709";
    readonly LUMA_601: "luma601";
    readonly MAX: "max";
    readonly MIN: "min";
    readonly AVERAGE: "average";
    readonly MINMAX: "minmax";
    readonly RED: "red";
    readonly GREEN: "green";
    readonly BLUE: "blue";
    readonly BLACK: "black";
    readonly CYAN: "cyan";
    readonly MAGENTA: "magenta";
    readonly YELLOW: "yellow";
    readonly HUE: "hue";
    readonly SATURATION: "saturation";
    readonly LIGHTNESS: "lightness";
};

export declare type GreyAlgorithm = (typeof GreyAlgorithm)[keyof typeof GreyAlgorithm];

/**
 * Call back that converts the RGB channels to grey. It is clamped afterwards.
 * @callback GreyAlgorithmCallback@callback GreyAlgorithmCallback
 * @param {number} red - Value of the red channel.
 * @param {number} green - Value of the green channel.
 * @param {number} blue - Value of the blue channel.
 * @returns {number} Value of the grey channel.
 */
export declare type GreyAlgorithmCallback = (red: number, green: number, blue: number, image: Image_2) => number;

export declare interface GreyOptions {
    /**
     * Specify the grey algorithm to use.
     * @default `'luma709'`
     */
    algorithm?: GreyAlgorithm | GreyAlgorithmCallback;
    /**
     * Specify wether to keep an alpha channel in the new image or not.
     * @default `false`
     */
    keepAlpha?: boolean;
    /**
     * Specify wether to merge the alpha channel with the gray pixel or not.
     * @default `true`
     */
    mergeAlpha?: boolean;
    /**
     * Image to which to output.
     */
    out?: Image_2;
}

/**
 * Returns a histogram of pixel intensities.
 * @param image - The original image.
 * @param options - Histogram options.
 * @returns - The histogram.
 */
export declare function histogram(image: Image_2, options?: HistogramOptions): Uint32Array;

export declare interface HistogramOptions {
    /**
     * The channel for which to compute the histogram.
     * If it is unspecified, the image must have one channel or the method will
     * throw an error.
     * @default `0`
     */
    channel?: number;
    /**
     * The number of slots that histogram can have.
     * @default 2 ** image.bitDepth
     */
    slots?: number;
}

/**
 * Calculate a new image that is the hypotenuse between the current image and the otherImage.
 * @param image - First image to process.
 * @param otherImage - Second image.
 * @param options - Hypotenuse options.
 * @returns Hypotenuse of the two images.
 */
export declare function hypotenuse(image: Image_2, otherImage: Image_2, options?: HypotenuseOptions): Image_2;

export declare interface HypotenuseOptions {
    /**
     * To which channels to apply the filter. By default all but alpha.
     */
    channels?: number[];
}

declare class Image_2 {
    /**
     * The number of columns of the image.
     */
    readonly width: number;
    /**
     * The number of rows of the image.
     */
    readonly height: number;
    /**
     * The total number of pixels in the image (width × height).
     */
    readonly size: number;
    /**
     * The number of bits per value in each channel.
     */
    readonly bitDepth: BitDepth;
    /**
     * The color model of the image.
     */
    readonly colorModel: ImageColorModel;
    /**
     * The number of color channels in the image, excluding the alpha channel.
     * A GREY image has 1 component. An RGB image has 3 components.
     */
    readonly components: number;
    /**
     * The total number of channels in the image, including the alpha channel.
     */
    readonly channels: number;
    /**
     * Whether the image has an alpha channel or not.
     */
    readonly alpha: boolean;
    /**
     * The maximum value that a pixel channel can have.
     */
    readonly maxValue: number;
    /**
     * Origin of the image relative to a the parent image.
     */
    readonly origin: Point;
    readonly meta?: ImageMetadata;
    /**
     * Typed array holding the image data.
     */
    private readonly data;
    /**
     * Construct a new Image knowing its dimensions.
     * @param width - Image width.
     * @param height - Image height.
     * @param options - Image options.
     */
    constructor(width: number, height: number, options?: ImageOptions);
    /**
     * Create a new Image based on the properties of an existing one.
     * @param other - Reference image.
     * @param options - Image options.
     * @returns New image.
     */
    static createFrom(other: Image_2 | Mask, options?: CreateFromOptions): Image_2;
    /**
     * Get all the channels of a pixel.
     * @param column - Column index.
     * @param row - Row index.
     * @returns Channels of the pixel.
     */
    getPixel(column: number, row: number): number[];
    getColumn(column: number): number[][];
    getRow(row: number): number[][];
    /**
     * Set all the channels of a pixel.
     * @param column - Column index.
     * @param row - Row index.
     * @param value - New color of the pixel to set.
     */
    setPixel(column: number, row: number, value: number[]): void;
    /**
     * Set all the channels of a pixel if the coordinates are inside the image.
     * @param column - Column index.
     * @param row - Row index.
     * @param value - New color of the pixel to set.
     */
    setVisiblePixel(column: number, row: number, value: number[]): void;
    /**
     * Get all the channels of a pixel using its index.
     * @param index - Index of the pixel.
     * @returns Channels of the pixel.
     */
    getPixelByIndex(index: number): number[];
    /**
     * Set all the channels of a pixel using its index.
     * @param index - Index of the pixel.
     * @param value - New channel values of the pixel to set.
     */
    setPixelByIndex(index: number, value: number[]): void;
    /**
     * Get the value of a specific pixel channel. Select pixel using coordinates.
     * @param column - Column index.
     * @param row - Row index.
     * @param channel - Channel index.
     * @returns Value of the specified channel of one pixel.
     */
    getValue(column: number, row: number, channel: number): number;
    /**
     * Set the value of a specific pixel channel. Select pixel using coordinates.
     * @param column - Column index.
     * @param row - Row index.
     * @param channel - Channel index.
     * @param value - Value to set.
     */
    setValue(column: number, row: number, channel: number, value: number): void;
    /**
     * Set the value of a specific pixel channel. Select pixel using coordinates.
     * If the value is out of range it is set to the closest extremety.
     * @param column - Column index.
     * @param row - Row index.
     * @param channel - Channel index.
     * @param value - Value to set.
     */
    setClampedValue(column: number, row: number, channel: number, value: number): void;
    /**
     * Get the value of a specific pixel channel. Select pixel using index.
     * @param index - Index of the pixel.
     * @param channel - Channel index.
     * @returns Value of the channel of the pixel.
     */
    getValueByIndex(index: number, channel: number): number;
    /**
     * Set the value of a specific pixel channel. Select pixel using index.
     * @param index - Index of the pixel.
     * @param channel - Channel index.
     * @param value - Value to set.
     */
    setValueByIndex(index: number, channel: number, value: number): void;
    /**
     * Set the value of a specific pixel channel. Select pixel using index.
     * If the value is out of range it is set to the closest extremety.
     * @param index - Index of the pixel.
     * @param channel - Channel index.
     * @param value - Value to set.
     */
    setClampedValueByIndex(index: number, channel: number, value: number): void;
    /**
     * Get the value of a specific pixel channel. Select pixel using a point.
     * @param point - Coordinates of the desired pixel.
     * @param channel - Channel index.
     * @returns Value of the channel of the pixel.
     */
    getValueByPoint(point: Point, channel: number): number;
    /**
     * Set the value of a specific pixel channel. Select pixel using a point.
     * @param point - Coordinates of the pixel.
     * @param channel - Channel index.
     * @param value - Value to set.
     */
    setValueByPoint(point: Point, channel: number, value: number): void;
    /**
     * Find the min and max values of each channel of the image.
     * @returns An object with arrays of the min and max values.
     */
    minMax(): {
        min: number[];
        max: number[];
    };
    /**
     * Return the raw image data.
     * @returns The raw data.
     */
    getRawImage(): {
        width: number;
        height: number;
        data: ImageDataArray;
        channels: number;
        bitDepth: BitDepth;
    };
    /**
     * Fill the image with a value or a color.
     * @param value - Value or color.
     * @returns The image instance.
     */
    fill(value: number | number[]): this;
    /**
     * Fill one channel with a value.
     * @param channel - The channel to fill.
     * @param value - The new value.
     * @returns The image instance.
     */
    fillChannel(channel: number, value: number): this;
    /**
     * Get one channel of the image as an array.
     * @param channel - The channel to fill.
     * @returns Array with the channel values.
     */
    getChannel(channel: number): number[];
    /**
     * Fill the alpha channel with the specified value.
     * @param value - New channel value.
     * @returns The image instance.
     */
    fillAlpha(value: number): this;
    /**
     * Create a copy of this image.
     * @returns The image clone.
     */
    clone(): Image_2;
    /**
     * Modify all the values of the image using the given callback.
     * @param cb - Callback that modifies a given value.
     */
    changeEach(cb: (value: number) => number): void;
    /**
     * Get the coordinates of a point in the image. The reference is the top-left corner.
     * @param coordinates - The point for which you want the coordinates.
     * @param round - Whether the coordinates should be rounded. This is useful when you want the center of the image.
     * @returns Coordinates of the point in the format [column, row].
     */
    getCoordinates(coordinates: ImageCoordinates, round?: boolean): Point;
    /**
     * Subtract other from an image.
     * @param other - Image to subtract.
     * @param options - Inversion options.
     * @returns The subtracted image.
     */
    subtract(other: Image_2, options?: SubtractImageOptions): Image_2;
    add(other: Image_2): Image_2;
    /**
     *  Multiply image pixels by a constant.
     * @param value - Value which pixels will be multiplied to.
     * @param options - Multiply options.
     * @returns Multiplied image.
     */
    multiply(value: number, options?: MultiplyOptions): Image_2;
    /**
     *  Divide image pixels by a constant.
     * @param value - Value which pixels will be divided to.
     * @param options - Divide options.
     * @returns Divided image.
     */
    divide(value: number, options?: DivideOptions): Image_2;
    histogram(options?: HistogramOptions): Uint32Array;
    /**
     * Compute the mean pixel of an image.
     * @param options - Mean options.
     * @returns The mean pixel.
     */
    mean(options?: MeanOptions): number[];
    /**
     * Compute the median pixel of an image.
     * @param options - Median options.
     * @returns The median pixel.
     */
    median(options?: MedianOptions): number[];
    /**
     * Compute the variance of each channel of an image.
     * @param options - Variance options.
     * @returns The variance of the channels of the image.
     */
    variance(options?: VarianceOptions): number[];
    /**
     * Draw a set of points on an image.
     * @param points - Array of points.
     * @param options - Draw points on Image options.
     * @returns New mask.
     */
    drawPoints(points: Point[], options?: DrawPointsOptions): Image_2;
    /**
     * Draw a line defined by two points onto an image.
     * @param from - Line starting point.
     * @param to - Line ending point.
     * @param options - Draw Line options.
     * @returns The mask with the line drawing.
     */
    drawLine(from: Point, to: Point, options?: DrawLineOnImageOptions): Image_2;
    /**
     * Draw a rectangle defined by position of the top-left corner, width and height.
     * @param options - Draw rectangle options.
     * @returns The image with the rectangle drawing.
     */
    drawRectangle(options?: DrawRectangleOptions<Image_2>): Image_2;
    /**
     * Draw a polyline defined by an array of points on an image.
     * @param points - Polyline array of points.
     * @param options - Draw polyline options.
     * @returns The image with the polyline drawing.
     */
    drawPolyline(points: Point[], options?: DrawPolylineOnImageOptions): Image_2;
    /**
     * Draw a polygon defined by an array of points onto an image.
     * @param points - Polygon vertices.
     * @param options - Draw Line options.
     * @returns The image with the polygon drawing.
     */
    drawPolygon(points: Point[], options?: DrawPolygonOnImageOptions): Image_2;
    /**
     * Draw a circle defined by center and radius onto an image.
     * @param center - Circle center.
     * @param radius - Circle radius.
     * @param options - Draw circle options.
     * @returns The image with the circle drawing.
     */
    drawCircle(center: Point, radius: number, options?: DrawCircleOnImageOptions): Image_2;
    /**
     * Draw a marker on the image.
     * @param point - Marker center point.
     * @param options - Draw marker options.
     * @returns The image with the marker drawing.
     */
    drawMarker(point: Point, options?: DrawMarkerOptions): Image_2;
    /**
     * Draw markers on the image.
     * @param points - Markers center points.
     * @param options - Draw marker options.
     * @returns The image with the markers drawing.
     */
    drawMarkers(points: Point[], options?: DrawMarkerOptions): Image_2;
    split(): Image_2[];
    convertColor(colorModel: ImageColorModel, options?: ConvertColorOptions): Image_2;
    convertBitDepth(newDepth: BitDepth, options?: ConvertBitDepthOptions): Image_2;
    grey(options?: GreyOptions): Image_2;
    copyTo(target: Image_2, options?: CopyToOptions<Image_2>): Image_2;
    threshold(options?: ThresholdOptions): Mask;
    /**
     * Crop the input image to a desired size.
     * @param [options] - Crop options.
     * @returns The new cropped image.
     */
    crop(options?: CropOptions): Image_2;
    /**
     * Crop an oriented rectangle from the image.
     * If the rectangle's length or width are not an integers, its dimension is expanded in both directions such as the length and width are integers.
     * @param points - The points of the rectangle. Points must be circling around the rectangle (clockwise or anti-clockwise)
     * @param options - Crop options, see {@link CropRectangleOptions}
     * @returns The cropped image. The orientation of the image is the one closest to the rectangle passed as input.
     */
    cropRectangle(points: Point[], options?: CropRectangleOptions): Image_2;
    /**
     * Crops the image based on the alpha channel
     * This removes lines and columns where the alpha channel is lower than a threshold value.
     * @param options - Crop alpha options.
     * @returns The cropped image.
     */
    cropAlpha(options?: CropAlphaOptions): Image_2;
    /**
     * Extract the pixels of an image, as specified in a mask.
     * @param mask - The mask defining which pixels to keep.
     * @param options - Extract options.
     * @returns The extracted image.
     */
    extract(mask: Mask, options?: ExtractOptions): Image_2;
    /**
     * Paint a mask onto an image and the given position and with the given color.
     * @param mask - Mask to paint on the image.
     * @param options - Paint mask options.
     * @returns The painted image.
     */
    paintMask(mask: Mask, options?: PaintMaskOnImageOptions): Image_2;
    blur(options: BlurOptions): Image_2;
    pixelate(options: PixelateOptions): Image_2;
    directConvolution(kernel: number[][], options?: ConvolutionOptions): Image_2;
    /**
     * Compute direct convolution of an image and return an array with the raw values.
     * @param kernel - Kernel used for the convolution.
     * @param options - Convolution options.
     * @returns Array with the raw convoluted values.
     */
    rawDirectConvolution(kernel: number[][], options?: ConvolutionOptions): Float64Array;
    separableConvolution(kernelX: number[], kernelY: number[], options?: ConvolutionOptions): Image_2;
    /**
     * Apply a gaussian filter to an image.
     * @param options - Gaussian blur options.
     * @returns The blurred image.
     */
    gaussianBlur(options: GaussianBlurOptions): Image_2;
    /**
     * Flip the image.
     * @param options - Flip options.
     * @returns The flipped image.
     */
    flip(options?: FlipOptions): Image_2;
    /**
     *   Invert the colors of the image.
     * @param options - Inversion options.
     * @returns The inverted image.
     */
    invert(options?: InvertOptions): Image_2;
    /**
     * Calculate a new image that is the hypotenuse between the current image and the other.
     * @param other - Other image.
     * @param options - Hypotenuse options.
     * @returns Hypotenuse of the two images.
     */
    hypotenuse(other: Image_2, options?: HypotenuseOptions): Image_2;
    /**
     * Apply a gradient filter to an image.
     * @param options - Gradient filter options.
     * @returns The gradient image.
     */
    gradientFilter(options: GradientFilterOptions): Image_2;
    /**
     * Apply a derivative filter to an image.
     * @param options - Derivative filter options.
     * @returns The processed image.
     */
    derivativeFilter(options?: DerivativeFilterOptions): Image_2;
    /**
     * Level the image using the optional input and output value. This function allows you to enhance the image's contrast.
     * @param options - Level options.
     * @returns The levelled image.
     */
    level(options?: LevelOptions): Image_2;
    /**
     * Increase the contrast of an image by spanning each channel on the range [0, image.maxValue].
     * @param options - Increase contrast options.
     * @returns The enhanced image.
     */
    increaseContrast(options?: IncreaseContrastOptions): Image_2;
    /**
     * Correct the colors in an image using the reference colors.
     * @param measuredColors - Colors from the image, which will be compared to the reference.
     * @param referenceColors - Reference colors.
     * @returns Image with the colors corrected.
     */
    correctColor(measuredColors: RgbColor[], referenceColors: RgbColor[]): Image_2;
    /**
     * Apply a median filter to the image.
     * @param options - Options to apply for median filter.
     * @returns Image after median filter.
     */
    medianFilter(options: MedianFilterOptions): Image_2;
    resize(options: ResizeOptions): Image_2;
    rotate(angle: RotateAngle): Image_2;
    transform(transformMatrix: number[][], options?: TransformOptions): Image_2;
    transformRotate(angle: number, options?: TransformRotateOptions): Image_2;
    /**
     * Erode an image.
     * @param options - Erode options.
     * @returns The eroded image.
     */
    erode(options?: ErodeOptions): Image_2;
    /**
     * Dilate an image.
     * @param options - Dilate options.
     * @returns The dilated image.
     */
    dilate(options?: DilateOptions): Image_2;
    /**
     * Open an image.
     * @param options - Open options.
     * @returns The opened image.
     */
    open(options?: OpenOptions): Image_2;
    /**
     * Close an image.
     * @param options - Close options.
     * @returns The closed image.
     */
    close(options?: CloseOptions): Image_2;
    /**
     * Top hat of an image.
     * @param options - Top hat options.
     * @returns The top-hatted image.
     */
    topHat(options?: TopHatOptions): Image_2;
    /**
     * Bottom hat of an image.
     * @param options - Bottom hat options.
     * @returns The bottom-hatted image.
     */
    bottomHat(options?: BottomHatOptions): Image_2;
    /**
     * Apply morphological gradient to an image.
     * @param options - Morphological gradient options.
     * @returns The processed image.
     */
    morphologicalGradient(options?: MorphologicalGradientOptions): Image_2;
    /**
     * Apply Canny edge detection to an image.
     * @param options - Canny edge detection options.
     * @returns The processed image.
     */
    cannyEdgeDetector(options?: CannyEdgeOptions): Mask;
}
export { Image_2 as Image }

export declare const ImageColorModel: {
    readonly GREY: "GREY";
    readonly GREYA: "GREYA";
    readonly RGB: "RGB";
    readonly RGBA: "RGBA";
    readonly BINARY: "BINARY";
};

export declare type ImageColorModel = (typeof ImageColorModel)[keyof typeof ImageColorModel];

export declare const ImageCoordinates: {
    readonly CENTER: "center";
    readonly TOP_LEFT: "top-left";
    readonly TOP_RIGHT: "top-right";
    readonly BOTTOM_LEFT: "bottom-left";
    readonly BOTTOM_RIGHT: "bottom-right";
};

export declare type ImageCoordinates = (typeof ImageCoordinates)[keyof typeof ImageCoordinates];

export declare type ImageDataArray = Uint8Array | Uint16Array | Uint8ClampedArray;

export declare const ImageFormat: {
    readonly PNG: "png";
    readonly JPG: "jpg";
    readonly JPEG: "jpeg";
    readonly BMP: "bmp";
};

export declare type ImageFormat = (typeof ImageFormat)[keyof typeof ImageFormat];

export declare interface ImageMetadata {
    tiff: {
        fields: Map<number, unknown>;
        tags: Record<string, unknown>;
    };
    exif: Record<string, unknown>;
}

export declare interface ImageOptions {
    /**
     * Number of bits per value in each channel.
     * @default `8`.
     */
    bitDepth?: BitDepth;
    /**
     * Typed array holding the image data.
     */
    data?: ImageDataArray;
    /**
     * Color model of the created image.
     * @default `'RGB'`.
     */
    colorModel?: ImageColorModel;
    /**
     * Origin of the image relative to a parent image (top-left corner).
     * @default `{row: 0, column: 0}`
     */
    origin?: Point;
    meta?: ImageMetadata;
}

export declare type ImageValues = [number, number, number, number];

/**
 * Increase the contrast of an image by spanning each channel on the range [0, image.maxValue].
 * This algorithm is based on the level algorithm.
 * @param image - The image to enhance.
 * @param options - Increase contrast options.
 * @returns The enhanced image.
 */
export declare function increaseContrast(image: Image_2, options?: IncreaseContrastOptions): Image_2;

export declare interface IncreaseContrastOptions {
    /**
     * Image to which to output.
     */
    out?: Image_2;
    /**
     * Level all channels uniformly in order to preserve the color balance.
     * @default false
     */
    uniform?: boolean;
}

export declare const InterpolationType: {
    readonly NEAREST: "nearest";
    readonly BILINEAR: "bilinear";
    readonly BICUBIC: "bicubic";
};

export declare type InterpolationType = (typeof InterpolationType)[keyof typeof InterpolationType];

export declare function invert(image: Image_2, options?: InvertOptions): Image_2;

export declare function invert(image: Mask, options?: InvertOptions): Mask;

export declare interface InvertOptions {
    /**
     * Image to which the inverted image has to be put.
     */
    out?: Image_2 | Mask;
}

declare interface IsFastKeypointOptions {
    /**
     * Number of contiguous pixels on the circle that should have an intensity difference with current pixel larger than threshold.
     * This value is recommended to be 3/4 of the circle points.
     * @default `3/4*circlePoints.length`
     */
    nbContiguousPixels?: number;
    /**
     * Threshold for the intensity difference.
     * @default `20`
     */
    threshold?: number;
}

/**
 * Level the image using the optional input and output value. The default options allow to increase the image's contrast.
 * @param image - Image to process.
 * @param options - Level options.
 * @returns The levelled image.
 */
export declare function level(image: Image_2, options?: LevelOptions): Image_2;

export declare interface LevelOptions {
    /**
     * Specify which channels should be processed. To process the alpha as well,
     * specify the channels as [0,1,2,3] for RGBA images and [0,1] for GREYA.
     * @default All components of the image the image (no alpha).
     */
    channels?: number[];
    /**
     * Input lower bound.
     * @default `image.minMax().min`
     */
    inputMin?: number | number[];
    /**
     * Input upper bound.
     * @default `image.minMax().min`
     */
    inputMax?: number | number[];
    /**
     * output lower bound.
     * @default `0`
     */
    outputMin?: number | number[];
    /**
     * Output upper bound.
     * @default `image.maxValue`
     */
    outputMax?: number | number[];
    /**
     * Specifies the shape of the curve connecting the two points.
     *  @default `1`
     */
    gamma?: number | number[];
    /**
     * Image to which to output.
     */
    out?: Image_2;
}

export declare class Mask {
    /**
     * The number of columns of the mask.
     */
    readonly width: number;
    /**
     * The number of rows of the mask.
     */
    readonly height: number;
    /**
     * The total number of bits in the mask (width × height).
     */
    readonly size: number;
    /**
     * The number of bits per value in each channel (always 1).
     */
    readonly bitDepth: BitDepth;
    /**
     * The color model of the mask (always BINARY).
     */
    readonly colorModel: ImageColorModel;
    /**
     * The number of color channels in the image, excluding the alpha channel (always 1).
     */
    readonly components: number;
    /**
     * The number of channels in the mask, including the alpha channel (always 1).
     */
    readonly channels: number;
    /**
     * Specifying that the mask has no an alpha channel.
     */
    readonly alpha: boolean;
    /**
     * The maximum value that a pixel channel can have.
     */
    readonly maxValue: number;
    /**
     * Origin of the image relative to a the parent image.
     */
    readonly origin: Point;
    /**
     * Typed array holding the mask data.
     */
    private readonly data;
    /**
     * Construct a new Mask knowing its dimensions.
     * @param width - Image width.
     * @param height - Image height.
     * @param options - Image options.
     */
    constructor(width: number, height: number, options?: MaskOptions);
    /**
     * Create a new Mask based on the properties of an existing one.
     * @param other - Reference Mask.
     * @param options - Mask options.
     * @returns New mask.
     */
    static createFrom(other: Mask | Image_2, options?: MaskCreateFromOptions): Mask;
    /**
     * Get a pixel of the mask.
     * @param column - Column index.
     * @param row - Row index.
     * @returns The pixel.
     */
    getPixel(column: number, row: number): number[];
    /**
     * Set a pixel.
     * @param column - Column index.
     * @param row - Row index.
     * @param value - The pixel value.
     */
    setPixel(column: number, row: number, value: number[]): void;
    /**
     * Set a pixel to a given value if the coordinates are inside the mask.
     * @param column - Column index.
     * @param row - Row index.
     * @param value - New color of the pixel to set.
     */
    setVisiblePixel(column: number, row: number, value: number[]): void;
    /**
     * Get a pixel using its index.
     * @param index - Index of the pixel.
     * @returns The pixel.
     */
    getPixelByIndex(index: number): number[];
    /**
     * Set a pixel using its index.
     * @param index - Index of the pixel.
     * @param value - New value of the pixel to set.
     */
    setPixelByIndex(index: number, value: number[]): void;
    /**
     * Create a mask from an array of points.
     * @param width - Width of the mask.
     * @param height - Height of the mask.
     * @param points - Reference Mask.
     * @returns New mask.
     */
    static fromPoints(width: number, height: number, points: Point[]): Mask;
    /**
     * Create a copy of this mask.
     * @returns The mask clone.
     */
    clone(): Mask;
    /**
     * Get the value of a bit.
     * @param column - Column index.
     * @param row - Row index.
     * @returns The bit value.
     */
    getBit(column: number, row: number): number;
    /**
     * Set the value of a bit.
     * @param column - Column index.
     * @param row - Row index.
     * @param value - New bit value.
     */
    setBit(column: number, row: number, value: BitValue): void;
    /**
     * Get the value of a bit using index.
     * @param index - Index of the pixel.
     * @returns Value of the bit.
     */
    getBitByIndex(index: number): number;
    /**
     * Set the value of a bit using index.
     * @param index - Index of the pixel.
     * @param value - Value to set.
     */
    setBitByIndex(index: number, value: BitValue): void;
    /**
     * Get the number of pixels that do not have the value 0.
     * @returns The number of non-zero pixels.
     */
    getNbNonZeroPixels(): number;
    /**
     * Get the value of a bit. Function exists for compatibility with Image.
     * @param column - Column index.
     * @param row - Row index.
     * @param channel - Index of the channel, must be zero.
     * @returns The bit value.
     */
    getValue(column: number, row: number, channel: number): number;
    /**
     * Set the value of a bit. Function exists for compatibility with Image.
     * @param column - Column index.
     * @param row - Row index.
     * @param channel - Index of the channel, must be zero.
     * @param value - New bit value.
     */
    setValue(column: number, row: number, channel: number, value: BitValue): void;
    /**
     * Get the value of a bit using index. Function exists for compatibility with Image.
     * @param index - Index of the pixel.
     * @param channel - Index of the channel, must be zero.
     * @returns Value of the bit.
     */
    getValueByIndex(index: number, channel: number): number;
    /**
     * Set the value of a bit using index. Function exists for compatibility with Image.
     * @param index - Index of the pixel.
     * @param channel - Index of the channel, must be zero.
     * @param value - Value to set.
     */
    setValueByIndex(index: number, channel: number, value: BitValue): void;
    /**
     * Get the value of a specific bit. Select bit using a point.
     * @param point - Coordinates of the desired biz.
     * @returns Value of the bit.
     */
    getValueByPoint(point: Point): number;
    /**
     * Set the value of a specific bit. Select bit using a point.
     * @param point - Coordinates of the bit.
     * @param value - Value to set.
     */
    setValueByPoint(point: Point, value: BitValue): void;
    /**
     * Return the raw mask data.
     * @returns The raw data.
     */
    getRawImage(): {
        width: number;
        height: number;
        data: Uint8Array<ArrayBufferLike>;
    };
    /**
     * Fill the mask with a value.
     * @param value - Value of the bit.
     * @returns The mask instance.
     */
    fill(value: BitValue): this;
    convertColor(colorModel: ImageColorModel): Image_2;
    /**
     * Invert the colors of the mask.
     * @param options - Inversion options.
     * @returns The inverted mask.
     */
    invert(options?: InvertOptions): Mask;
    /**
     * Subtract other from a mask.
     * @param other - Image to subtract.
     * @param options - Inversion options.
     * @returns The subtracted mask.
     */
    subtract(other: Mask, options?: SubtractImageOptions): Mask;
    /**
     * Perform an AND operation on two masks.
     * @param other - Second mask.
     * @param options - And options.
     * @returns AND of the two masks.
     */
    and(other: Mask, options?: AndOptions): Mask;
    /**
     * Perform an OR operation on two masks.
     * @param other - Second mask.
     * @param options - And options.
     * @returns OR of the two masks.
     */
    or(other: Mask, options?: OrOptions): Mask;
    /**
     * Get the coordinates of the points on the border of a shape defined in a mask.
     * @param options - Get border points options.
     * @returns Array of border points.
     */
    getBorderPoints(options?: GetBorderPointsOptions): Point[];
    /**
     * Get the vertices of the convex Hull polygon of a mask.
     * @returns Array of the vertices of the convex Hull in clockwise order.
     */
    getConvexHull(): ConvexHull;
    /**
     * Get the corners of the minimum bounding rectangle of a shape defined in a mask.
     * @returns Array of border points.
     */
    getMbr(): Mbr;
    /**
     * Computes the Feret data.
     * @returns The Feret diameters.
     */
    getFeret(): Feret;
    /**
     * Erode a Mask.
     * @param options - Erode options.
     * @returns The eroded mask.
     */
    erode(options?: ErodeOptions): Mask;
    /**
     * Dilate an image.
     * @param options - Dilate options.
     * @returns The dilated image.
     */
    dilate(options?: DilateOptions): Mask;
    /**
     * Open an image.
     * @param options - Open options.
     * @returns The opened image.
     */
    open(options?: OpenOptions): Mask;
    /**
     * Close an image.
     * @param options - Close options.
     * @returns The closed image.
     */
    close(options?: CloseOptions): Mask;
    /**
     * Top hat of an image.
     * @param options - Top hat options.
     * @returns The top-hatted image.
     */
    topHat(options?: TopHatOptions): Mask;
    /**
     * Bottom hat of an image.
     * @param options - Bottom hat options.
     * @returns The bottom-hatted image.
     */
    bottomHat(options?: BottomHatOptions): Mask;
    /**
     * Apply morphological gradient to an image.
     * @param options - Morphological gradient options.
     * @returns The processed image.
     */
    morphologicalGradient(options?: MorphologicalGradientOptions): Mask;
    /**
     * Remove elements connected to the borders of an image.
     * @param options - Clear border options.
     * @returns The processed image.
     */
    clearBorder(options?: ClearBorderOptions): Mask;
    /**
     * Apply flood fill algorithm from a given starting point.
     * @param options - Flood fill options.
     * @returns The filled mask.
     */
    floodFill(options?: FloodFillOptions): Mask;
    /**
     * Fill holes in regions of interest.
     * @param options - Flood fill options.
     * @returns The filled mask.
     */
    solidFill(options?: SolidFillOptions): Mask;
    /**
     * Draw a set of points on a mask.
     * @param points - Array of points.
     * @param options - Draw points on Image options.
     * @returns New mask.
     */
    drawPoints(points: Point[], options?: DrawPointsOptions): Mask;
    /**
     * Draw a line defined by two points onto a mask.
     * @param from - Line starting point.
     * @param to - Line ending point.
     * @param options - Draw Line options.
     * @returns The mask with the line drawing.
     */
    drawLine(from: Point, to: Point, options?: DrawLineOnMaskOptions): Mask;
    /**
     * Draw a polyline defined by an array of points on a mask.
     * @param points - Polyline array of points.
     * @param options - Draw polyline options.
     * @returns The mask with the polyline drawing.
     */
    drawPolyline(points: Point[], options?: DrawPolylineOnMaskOptions): Mask;
    /**
     * Draw a polygon defined by an array of points onto an mask.
     * @param points - Polygon vertices.
     * @param options - Draw Line options.
     * @returns The mask with the polygon drawing.
     */
    drawPolygon(points: Point[], options?: DrawPolygonOnMaskOptions): Mask;
    /**
     * Draw a rectangle defined by position of the top-left corner, width and height.
     * @param options - Draw rectangle options.
     * @returns The image with the rectangle drawing.
     */
    drawRectangle(options?: DrawRectangleOptions<Mask>): Mask;
    /**
     * Copy the mask to another one by specifying the location in the target mask.
     * @param target - The target mask.
     * @param options - Options.
     * @returns The target with the source copied to it.
     */
    copyTo(target: Mask, options?: CopyToOptions<Mask>): Mask;
    /**
     * Paint a mask onto another mask and the given position and with the given value.
     * @param mask - Mask to paint.
     * @param options - Paint mask options.
     * @returns The painted mask.
     */
    paintMask(mask: Mask, options?: PaintMaskOnMaskOptions): Mask;
}

export declare interface MaskCreateFromOptions extends MaskOptions {
    width?: number;
    height?: number;
}

export declare interface MaskOptions {
    /**
     * Origin of the image relative to a parent image.
     * @default `{row: 0, column: 0 }`
     */
    origin?: Point;
    /**
     * Typed array holding the mask data.
     */
    data?: Uint8Array;
}

export declare interface Match {
    /**
     * Index of the source keypoint.
     */
    sourceIndex: number;
    /**
     * Index of the destination keypoint.
     */
    destinationIndex: number;
    /**
     * Distance from source to destination keypoints.
     */
    distance: number;
}

/**
 * Minimum bounding rectangle of a mask.
 */
export declare interface Mbr {
    /**
     * Vertices of the MBR in clockwise order.
     */
    points: Point[];
    /**
     * Perimeter of the MBR.
     */
    perimeter: number;
    /**
     * Surface of the MBR.
     */
    surface: number;
    /**
     * Width of the rectangle.
     */
    width: number;
    /**
     * Height of the rectangle.
     */
    height: number;
    /**
     * Angle between the rectangle and a horizontal line in radians.
     */
    angle: number;
    /**
     * Ratio between width and height.
     */
    aspectRatio: number;
}

/**
 * Compute the mean of an image. The mean can be either computed on each channel
 * individually or on the whole image.
 * @param image - Image to process.
 * @param options - Mean options.
 * @returns The mean pixel.
 */
export declare function mean(image: Image_2, options?: MeanOptions): number[];

export declare interface MeanOptions {
    /**
     * Points to calculate mean from.
     */
    points: Point[];
}

/**
 * Returns the median pixel of the image. The median is computed on each channel individually.
 * @param image - Image to process.
 * @param options - Median options.
 * @returns Median pixel.
 */
export declare function median(image: Image_2, options?: MedianOptions): number[];

/**
 * Calculate a new image that replaces all pixel values by the median of neighbouring pixels.
 * @param image - Image to be filtered.
 * @param options - MedianFilterOptions
 * @returns Image after median filter.
 */
export declare function medianFilter(image: Image_2, options: MedianFilterOptions): Image_2;

export declare interface MedianFilterOptions {
    /**
     * Type of border algorithm to interpolate from.
     * @default `'reflect101'`
     */
    borderType: BorderType;
    /**
     * Value of border.
     */
    borderValue?: number;
    /**
     * The radius of the cell to extract median value from. Must be odd.
     *  @default `1`
     */
    cellSize: number;
}

export declare interface MedianOptions {
    /**
     * Points to calculate median from.
     */
    points: Point[];
}

/**
 * Inverse of split. Merges multiple single-channel images into one.
 * @param images - An array of single-channel images.
 * @returns The merged image.
 */
export declare function merge(images: Image_2[]): Image_2;

export declare class Montage {
    /**
     * Scaled width of the first image.
     */
    readonly sourceWidth: number;
    /**
     * Scaled height of the first image.
     */
    readonly sourceHeight: number;
    /**
     * Scaled width of the second image.
     */
    readonly destinationWidth: number;
    /**
     * Scaled height of the second image.
     */
    readonly destinationHeight: number;
    /**
     * Origin of the destination / second image relative to top-left corner of the Montage.
     */
    readonly destinationOrigin: Point;
    /**
     * Width of the Montage.
     */
    readonly width: number;
    /**
     * Height of the Montage.
     */
    readonly height: number;
    /**
     * Factor by which to scale the images are scaled in the montage.
     */
    readonly scale: number;
    readonly disposition: MontageDisposition;
    /**
     * Image of the Montage.
     */
    image: Image_2;
    /**
     * Create a Montage of two images. The two images are placed side by side for comparison.
     * @param source - First image.
     * @param destination - Second image.
     * @param options  - Montage options.
     */
    constructor(source: Image_2, destination: Image_2, options?: MontageOptions);
    /**
     * Draw keypoints on the Montage.
     * @param keypoints - Keypoints to draw.
     * @param options - Draw keypoints options.
     */
    drawKeypoints(keypoints: FastKeypoint[], options?: DrawKeypointsOptions): void;
    /**
     * Draw the matches between source and destination keypoints.
     * @param matches - Matches to draw.
     * @param sourceKeypoints - Source keypoints.
     * @param destinationKeypoints  - Destination keypoints.
     * @param options - Draw matches options.
     */
    drawMatches(matches: Match[], sourceKeypoints: FastKeypoint[], destinationKeypoints: FastKeypoint[], options?: DrawMatchesOptions): void;
}

export declare const MontageDisposition: {
    readonly HORIZONTAL: "horizontal";
    readonly VERTICAL: "vertical";
};

export declare type MontageDisposition = (typeof MontageDisposition)[keyof typeof MontageDisposition];

export declare interface MontageOptions {
    /**
     * Factor by which to scale the images.
     *  @default `1`
     */
    scale?: number;
    /**
     * How should the images be aligned: vertically or horizontally.
     * @default `'horizontal'`
     */
    disposition?: MontageDisposition;
}

export declare function morphologicalGradient(image: Image_2, options?: MorphologicalGradientOptions): Image_2;

export declare function morphologicalGradient(image: Mask, options?: MorphologicalGradientOptions): Mask;

export declare interface MorphologicalGradientOptions {
    /**
     * 3x3 matrix. The kernel can only have ones and zeros.
     * Accessing a value: kernel[row][column].
     * @default `[[1, 1, 1], [1, 1, 1], [1, 1, 1]]`
     */
    kernel?: number[][];
    /**
     * Number of iterations of the algorithm.
     * @default `1`
     */
    iterations?: number;
}

/**
 *
 * Multiplies points by a certain value.
 * @param image - image to which multiplication will be applied.
 * @param value - Value by which each pixel will be multiplied.
 * @param options - Multiply options
 * @returns image.
 */
export declare function multiply(image: Image_2, value: number, options?: MultiplyOptions): Image_2;

export declare interface MultiplyOptions {
    /**
     * Channels where value will be multiplied.
     * @default all channels
     */
    channels?: number[];
    /**
     * Image to which the resulting image has to be put.
     */
    out?: Image_2;
}

declare function open_2(image: Image_2, options?: OpenOptions): Image_2;

declare function open_2(image: Mask, options?: OpenOptions): Mask;
export { open_2 as open }

export declare interface OpenOptions {
    /**
     * 3x3 matrix. The kernel can only have ones and zeros.
     * Accessing a value: kernel[row][column].
     * @default `[[1, 1, 1], [1, 1, 1], [1, 1, 1]]`
     */
    kernel?: number[][];
    /**
     * Number of iterations of the algorithm.
     * @default `1`
     */
    iterations?: number;
}

/**
 * Perform an OR operation on two masks.
 * @param mask - First mask.
 * @param otherMask - Second mask.
 * @param options - Or options.
 * @returns OR of the two masks.
 */
export declare function or(mask: Mask, otherMask: Mask, options?: OrOptions): Mask;

/**
 * Sorts 4 points in order =>[top-left,top-right,bottom-right,bottom-left]. Input points must be in clockwise or counter-clockwise order.
 * @param pts - Array of 4 points.
 * @returns Sorted array of 4 points.
 */
export declare function order4Points(pts: Point[]): Point[];

export declare interface OrientedFastKeypoint extends FastKeypoint {
    /**
     * Orientation of the keypoint defined as the angle in degrees between the x axis , the keypoints origin and the center of mass of the keypoint.
     */
    angle: number;
}

export declare interface OrOptions {
    /**
     * Image to which the resulting image has to be put.
     */
    out?: Mask;
}

export declare interface OverlapImageOptions {
    /**
     * Origin of the second image relatively to top-left corner of first image.
     * @default `{row: 0, column: 0}`
     */
    origin?: Point;
    /**
     * Desired rotation of image 2 in degrees around its top-left corner.
     * @default `0`
     */
    angle?: number;
    /**
     * Factor by which to scale the second image.
     *  @default `1`
     */
    scale?: number;
}

/**
 * Overlap two images and specify. The first image can be translated,
 * rotated and scaled to match the second one.
 * The first image is drawn in red and the second one in green.
 * @param image1 - First image.
 * @param image2 - Second image.
 * @param options - Overlap image options.
 * @returns The overlapping images.
 */
export declare function overlapImages(image1: Image_2, image2: Image_2, options?: OverlapImageOptions): Image_2;

/**
 * Paint a mask onto an image and the given position and with the given color.
 * @param image - Image on which to paint the mask.
 * @param mask - Mask to paint on the image.
 * @param options - Paint mask options.
 * @returns The painted image.
 */
export declare function paintMaskOnImage(image: Image_2, mask: Mask, options?: PaintMaskOnImageOptions): Image_2;

export declare interface PaintMaskOnImageOptions {
    /**
     * Top-left corner of the mask relative to a parent image.
     * @default `{row: 0, column: 0}`
     */
    origin?: Point;
    /**
     * Color with which to blend the image pixel.
     * @default Opaque black.
     */
    color?: Array<number | null>;
    /**
     * Whether the given color should be blended with the original pixel.
     * @default `true`
     */
    blend?: boolean;
    /**
     * Image to which to output.
     */
    out?: Image_2;
}

/**
 * Paint a mask onto an image and the given position and with the given color.
 * @param image - Image on which to paint the mask.
 * @param mask - Mask to paint on the image.
 * @param options - Paint mask options.
 * @returns The painted image.
 */
export declare function paintMaskOnMask(image: Mask, mask: Mask, options?: PaintMaskOnMaskOptions): Mask;

export declare interface PaintMaskOnMaskOptions {
    /**
     * Top-left corner of the mask relative to a parent image.
     * @default `{row: 0, column: 0}`
     */
    origin?: Point;
    /**
     * Value with which to set the pixel.
     * @default `1`
     */
    value?: BitValue;
    /**
     * Mask to which to output.
     */
    out?: Mask;
}

/**
 * Function to pixelate an image.
 * @param image - Image to be pixelated.
 * @param options - PixelateOptions.
 * @returns Pixelated Image.
 */
export declare function pixelate(image: Image_2, options: PixelateOptions): Image_2;

export declare interface PixelateOptions {
    /**
     *  Range of pixelated area.
     */
    cellSize: number;
    /**
     * algorithm to use.
     * @default `'center'`
     */
    algorithm?: 'center' | 'median' | 'mean';
    /**
     * Image to which to output.
     */
    out?: Image_2;
}

/**
 * Coordinates of a point in an image with the top-left corner being the reference point.
 */
export declare interface Point {
    /**
     * Point row.
     *
     */
    row: number;
    /**
     * Point column.
     *
     */
    column: number;
}

/**
 * Compute direct convolution of an image and return an array with the raw values.
 * @param image - Image to process.
 * @param kernel - 2D kernel used for the convolution.
 * @param options - Convolution options.
 * @returns Array with the raw convoluted values.
 */
export declare function rawDirectConvolution(image: Image_2, kernel: number[][], options?: ConvolutionOptions): Float64Array;

/**
 * Read an image from the disk.
 * The file format is automatically selected based on the first few bytes.
 * This method is only implemented for Node.js.
 * @param path - The path to the image.
 * @returns Image instance.
 */
export declare function read(path: string | URL): Promise<Image_2>;

/**
 * Read an image from an HTML canvas element.
 * @param canvas - Canvas element.
 * @returns The read image.
 */
export declare function readCanvas(canvas: HTMLCanvasElement): Image_2;

/**
 * Read an image from an HTML image source.
 * @param img - Image source such as an <img> or <svg> element.
 * @returns The read image.
 */
export declare function readImg(img: Extract<CanvasImageSource, Record<'width' | 'height', number>>): Image_2;

/**
 * Synchronous version of @see {@link read}.
 * This method is only implemented for Node.js.
 * @param path - The path to the image.
 * @returns Image instance.
 */
export declare function readSync(path: string | URL): Image_2;

/**
 * Finds extreme values of an image which are not stacked together.
 * @param points - Array of points that should be combined to improve.
 * @param image - Image which extrema are calculated from.
 * @param options - FilterPointsOptions
 * @returns Array of Points.
 */
export declare function removeClosePoints(points: Point[], image: Image_2, options: RemoveClosePointsOptions): Point[];

export declare interface RemoveClosePointsOptions {
    /**
     * The minimum distance between points in the returned filtered points. If the distance is less or equal to 0, no point is removed.
     * @default `0`
     */
    distance: number;
    /**
     * Shows what kind of extremum is being computed.
     * @default `'maximum'`
     */
    kind: 'minimum' | 'maximum';
    /**
     * Channel number of an image where the extremum should be found.
     * @default `0`
     */
    channel?: number;
}

/**
 * Returns a resized copy of an image.
 * @param image - Original image.
 * @param options - Resize options.
 * @returns The new image.
 */
export declare function resize(image: Image_2, options: ResizeOptions): Image_2;

export declare interface ResizeOptions {
    /**
     * Width of the output image.
     */
    width?: number;
    /**
     * Height of the output image.
     */
    height?: number;
    /**
     * Factor by which to scale the width.
     */
    xFactor?: number;
    /**
     * Factor by which to scale the width.
     */
    yFactor?: number;
    /**
     * Whether the aspect ratio of the image should be preserved.
     * @default `true`
     */
    preserveAspectRatio?: boolean;
    /**
     * Method to use to interpolate the new pixels.
     * @default `'bilinear'`
     */
    interpolationType?: InterpolationType;
    /**
     * Specify how the borders should be handled.
     * @default `'constant'`
     */
    borderType?: BorderType;
    /**
     * Value of the border if BorderType is 'constant'.
     * @default `0`
     */
    borderValue?: number;
}

declare type RgbColor = {
    r: number;
    g: number;
    b: number;
};

export declare class Roi {
    #private;
    /**
     * Original map with all the ROI IDs.
     */
    private readonly map;
    /**
     * ID of the ROI. Positive for white ROIs and negative for black ones.
     */
    readonly id: number;
    /**
     * Origin of the ROI. The top-left corner of the rectangle around
     * the ROI relative to the original image.
     */
    readonly origin: Point;
    /**
     * Width of the ROI.
     */
    readonly width: number;
    /**
     * Height of the ROI.
     */
    readonly height: number;
    /**
     * Surface of the ROI.
     */
    readonly surface: number;
    constructor(map: RoiMap, id: number, width: number, height: number, origin: Point, surface: number);
    /**
     * Return the value at the given coordinates in an ROI map.
     * @param column - Column of the value.
     * @param row - Row of the value.
     * @returns The value at the given coordinates.
     */
    getMapValue(column: number, row: number): number;
    /**
     * Returns the ratio between the width and the height of the bounding rectangle of the ROI.
     * @returns The width by height ratio.
     */
    getRatio(): number;
    /**
     * Generates a mask of an ROI. You can specify the kind of mask you want using the `kind` option.
     * @param options - Get Mask options.
     * @returns The ROI mask.
     */
    getMask(options?: GetMaskOptions): Mask;
    /**
     * Computes the diameter of a circle that has the same perimeter as the particle image.
     * @returns Ped value in pixels.
     */
    get ped(): number;
    /**
     * Return an array with the coordinates of the pixels that are on the border of the ROI.
     * The points are defined as [column, row].
     * @param options - Get border points options.
     * @returns The array of border pixels.
     */
    getBorderPoints(options?: GetBorderPointsOptions): Point[];
    /**
     * Returns an array of ROIs IDs that are included in the current ROI.
     * This will be useful to know if there are some holes in the ROI.
     * @returns InternalIDs.
     */
    get internalIDs(): number[];
    /**
     * Returns an array of ROIs IDs that touch the current ROI.
     * @returns The array of Borders.
     */
    get externalBorders(): Border[];
    /**
     * Calculates and caches the number of sides by which each pixel is touched externally.
     * @returns An object which tells how many pixels are exposed externally to how many sides.
     */
    get perimeterInfo(): {
        one: number;
        two: number;
        three: number;
        four: number;
    };
    /**
     * Perimeter of the ROI.
     * The perimeter is calculated using the sum of all the external borders of the ROI to which we subtract:
     * (2 - √2) * the number of pixels that have 2 external borders
     * 2 * (2 - √2) * the number of pixels that have 3 external borders
     * @returns Perimeter value in pixels.
     */
    get perimeter(): number;
    /**
     * Computes ROI points relative to ROIs point of `origin`.
     * @returns Array of points with relative ROI coordinates.
     */
    get relativePoints(): Point[];
    /**
     * Computes ROI points relative to Image's/Mask's point of `origin`.
     * @returns Array of points with absolute ROI coordinates.
     */
    get absolutePoints(): Point[];
    get boxIDs(): number[];
    /**
     * Computes the diameter of a circle of equal projection area (EQPC).
     * It is a diameter of a circle that has the same surface as the ROI.
     * @returns `eqpc` value in pixels.
     */
    get eqpc(): number;
    /**
     * Computes ellipse of ROI. It is the smallest ellipse that fits the ROI.
     * @returns Ellipse
     */
    get ellipse(): Ellipse;
    /**
     * Number of holes in the ROI and their total surface.
     * Used to calculate fillRatio.
     * @returns The surface of holes in ROI in pixels.
     */
    get holesInfo(): {
        number: number;
        surface: number;
    };
    /**
     * Calculates and caches border's length and their IDs.
     * @returns Borders' length and their IDs.
     */
    get borders(): Border[];
    /**
     * Computes fill ratio of the ROI. It is calculated by dividing ROI's actual surface over the surface combined with holes, to see how holes affect its surface.
     * @returns Fill ratio value.
     */
    get fillRatio(): number;
    /**
     * Computes sphericity of the ROI.
     * Sphericity is a measure of the degree to which a particle approximates the shape of a sphere, and is independent of its size. The value is always between 0 and 1. The less spheric the ROI is the smaller is the number.
     * @returns Sphericity value.
     */
    get sphericity(): number;
    /**
     * Computes the surface of the ROI, including the surface of the holes.
     * @returns Surface including holes measured in pixels.
     */
    get filledSurface(): number;
    /**
     * The solidity describes the extent to which a shape is convex or concave.
     * The solidity of a completely convex shape is 1, the farther the it deviates from 1, the greater the extent of concavity in the shape of the ROI.
     * @returns Solidity value.
     */
    get solidity(): number;
    /**
     *Computes convex hull. It is the smallest convex set that contains it.
     * @see https://en.wikipedia.org/wiki/Convex_hull
     * @returns Convex hull.
     */
    get convexHull(): {
        points: Point[];
        surface: number;
        perimeter: number;
    };
    /**
     * Computes the minimum bounding rectangle.
     * In digital image processing, the bounding box is merely the coordinates of the rectangular border that fully encloses a digital image when it is placed over a page, a canvas, a screen or other similar bidimensional background.
     * @returns The minimum bounding rectangle.
     */
    get mbr(): Mbr;
    get roundness(): number;
    /**
     * This is not a diameter in its actual sense but the common basis of a group of diameters derived from the distance of two tangents to the contour of the particle in a well-defined orientation.
     * In simpler words, the method corresponds to the measurement by a slide gauge (slide gauge principle).
     * In general it is defined as the distance between two parallel tangents of the particle at an arbitrary angle. The minimum Feret diameter is often used as the diameter equivalent to a sieve analysis.
     * @returns The maximum and minimum Feret Diameters.
     */
    get feret(): Feret;
    /**
     * A JSON object with all the data about ROI.
     * @returns All current ROI properties as one object.
     */
    toJSON(): {
        id: number;
        origin: Point;
        height: number;
        width: number;
        surface: number;
        eqpc: number;
        ped: number;
        feret: Feret;
        fillRatio: number;
        sphericity: number;
        roundness: number;
        solidity: number;
        perimeter: number;
        convexHull: {
            points: Point[];
            surface: number;
            perimeter: number;
        };
        mbr: Mbr;
        filledSurface: number;
        centroid: Point;
    };
    /**
     * Computes a center of mass of the current ROI.
     * @returns point
     */
    get centroid(): Point;
    /**
     * Generator function to calculate point's coordinates.
     * @param absolute - controls whether coordinates should be relative to ROI's point of `origin` (relative), or relative to ROI's position on the Image/Mask (absolute).
     * @yields Coordinates of each point of ROI.
     */
    points(absolute: boolean): Generator<{
        column: number;
        row: number;
    }, void, unknown>;
}

export declare const RoiKind: {
    readonly BLACK: "black";
    readonly WHITE: "white";
    readonly BW: "bw";
};

export declare type RoiKind = (typeof RoiKind)[keyof typeof RoiKind];

export declare interface RoiManager {
    getRois(options: GetRoisOptions): Roi[];
}

export declare interface RoiMap {
    /**
     * Width of the map.
     */
    width: number;
    /**
     * Height of the map.
     */
    height: number;
    /**
     * Data of the ROIs. Each ROI is associated with a negative or a positive value,
     * depending if it derives from a zone made of zeros or ones in the original mask.
     */
    data: Int32Array;
    /**
     * Number of distinct positive values in the ROI map.
     *
     */
    nbPositive: number;
    /**
     * Number of distinct negative values in the ROI map.
     *
     */
    nbNegative: number;
}

export declare class RoiMapManager implements RoiManager {
    private map;
    whiteRois: Roi[];
    blackRois: Roi[];
    constructor(map: RoiMap);
    /**
     * Return the ROI map of the RoiMapManager.
     * @returns - The ROI map.
     */
    getMap(): RoiMap;
    /**
     * Return the value at the given coordinates in an ROI map.
     * @param column - Column of the value.
     * @param row - Row of the value.
     * @returns The value at the given coordinates.
     */
    getMapValue(column: number, row: number): number;
    /**
     * Returns the ROI map as a correct width and height matrix.
     * @returns The ROI map matrix.
     */
    getMapMatrix(): number[][];
    getRois(options?: GetRoisOptions): Roi[];
    getRoiById(roiID: number): Roi;
    static fromMask(mask: Mask, options?: FromMaskOptions): RoiMapManager;
}

export declare const RoisColorMode: {
    /**
     * Only two acceptable values: red or green.
     */
    readonly BINARY: "binary";
    /**
     * Palette of reds and blues.
     */
    readonly SATURATION: "saturation";
    /**
     * All possible hues (gradient of colors).
     */
    readonly RAINBOW: "rainbow";
};

export declare type RoisColorMode = (typeof RoisColorMode)[keyof typeof RoisColorMode];

/**
 * Rotates an image in multiples of 90 degrees.
 * @param image - The image to rotate.
 * @param angle - The angle to rotate the image by. Positive values rotate clockwise, negative values rotate counter-clockwise.
 * @returns - The rotated image.
 */
export declare function rotate(image: Image_2, angle: RotateAngle): Image_2;

export declare type RotateAngle = 90 | 180 | 270 | -90 | -180 | -270;

/**
 * Compute the separable convolution of an image.
 * @param image - Image to convolute.
 * @param kernelX - Kernel along x axis.
 * @param kernelY - Kernel along y axis.
 * @param options - Convolution options.
 * @returns The convoluted image.
 */
export declare function separableConvolution(image: Image_2, kernelX: number[], kernelY: number[], options?: ConvolutionOptions): Image_2;

/**
 * Fill holes in regions of interest.
 * @param mask - Mask to process.
 * @param options - Flood fill options.
 * @returns The filled mask.
 */
export declare function solidFill(mask: Mask, options?: SolidFillOptions): Mask;

export declare interface SolidFillOptions {
    /**
     * Consider pixels connected by corners?
     * @default `false`
     */
    allowCorners?: boolean;
    /**
     * Image to which the inverted image has to be put.
     */
    out?: Mask;
}

/**
 * Create an array of single-channel images based on a multi-channel image.
 * @param image - The image with many channels.
 * @returns Array of single-channel images.
 */
export declare function split(image: Image_2): Image_2[];

export declare class Stack {
    /**
     * The array of images.
     */
    private readonly images;
    /**
     * The stack size.
     */
    readonly size: number;
    /**
     * Do the images have an alpha channel?
     */
    readonly alpha: boolean;
    /**
     * The color model of the images.
     */
    readonly colorModel: ImageColorModel;
    /**
     * The bit depth of the images.
     */
    readonly bitDepth: BitDepth_2;
    /**
     * Whether all the images of the stack have the same dimensions.
     */
    readonly sameDimensions: boolean;
    /**
     * The number of channels of the images.
     */
    readonly channels: number;
    /**
     * Create a new stack from an array of images.
     * The images must have the same bit depth and color model.
     * @param images - Array of images from which to create the stack.
     */
    constructor(images: Image_2[]);
    [Symbol.iterator](): IterableIterator<Image_2>;
    /**
     * Clone a stack. The images are a copy of the original images.
     * @returns A new stack with the same images.
     */
    clone(): Stack;
    /**
     * Get the images of the stack. Mainly for debugging purposes.
     * @returns The images.
     */
    getImages(): Image_2[];
    /**
     * Get the image at the given index.
     * @param index - The index of the image.
     * @returns The image.
     */
    getImage(index: number): Image_2;
    /**
     * Get a value from an image of the stack.
     * @param stackIndex - Index of the image in the stack.
     * @param row - Row index of the pixel.
     * @param column - Column index of the pixel.
     * @param channel - The channel to retrieve.
     * @returns The value at the given position.
     */
    getValue(stackIndex: number, row: number, column: number, channel: number): number;
    /**
     * Get a value from an image of the stack. Specify the pixel position using its index.
     * @param stackIndex - Index of the image in the stack.
     * @param index - The index of the pixel.
     * @param channel - The channel to retrieve.
     * @returns The value at the given position.
     */
    getValueByIndex(stackIndex: number, index: number, channel: number): number;
    /**
     * Return the image containing the minimum values of all the images in the stack for
     * each pixel. All the images must have the same dimensions.
     * @returns The minimum image.
     */
    minImage(): Image_2;
    /**
     * Return the image containing the maximum values of all the images in the stack for
     * each pixel. All the images must have the same dimensions.
     * @returns The maximum image.
     */
    maxImage(): Image_2;
    /**
     * Return the image containing the median values of all the images in the stack for
     * each pixel. All the images must have the same dimensions.
     * @returns The median image.
     */
    medianImage(): Image_2;
    /**
     * Return the image containing the average values of all the images in the stack for
     * each pixel. All the images must have the same dimensions.
     * @returns The mean image.
     */
    meanImage(): Image_2;
    /**
     * Return a 16 bits depth image containing the sum values of all the images in the stack for
     * each pixel.
     * @returns The sum image.
     */
    sum(): Image_2;
    /**
     * Get the sum of all the histograms of the stack's images. If no channel is specified in the options, the images must be GREY.
     * @param options - Histogram options.
     * @returns The histogram of the stack.
     */
    histogram(options?: HistogramOptions): Uint32Array;
    /**
     * Align all the images of the stack on the image at the given index.
     * @param refIndex - The index of the reference image.
     */
    /**
     * Map a function on all the images of the stack.
     * @param callback - Function to apply on each image.
     * @returns New stack with the modified images.
     */
    map(callback: (image: Image_2) => Image_2): Stack;
    /**
     * Filter the images in the stack.
     * @param callback - Function to decide which images to keep.
     * @returns New filtered stack.
     */
    filter(callback: (image: Image_2) => boolean): Stack;
}

export declare function subtract(image: Image_2, otherImage: Image_2, options?: SubtractImageOptions): Image_2;

export declare function subtract(image: Mask, otherImage: Mask, options?: SubtractImageOptions): Mask;

export declare function subtract(image: Image_2 | Mask, otherImage: Image_2 | Mask, options: SubtractImageOptions): Image_2 | Mask;

export declare interface SubtractImageOptions {
    /**
     * Return the absolute difference for each pixel.
     * @default `false`
     */
    absolute?: boolean;
}

/**
 * Create a black and white image based on a threshold value.
 * @param image - The grey image to convert.
 * @param options - Threshold options.
 * @returns The resulting mask.
 */
export declare function threshold(image: Image_2, options?: ThresholdOptions): Mask;

export declare const ThresholdAlgorithm: {
    readonly HUANG: "huang";
    readonly INTERMODES: "intermodes";
    readonly ISODATA: "isodata";
    readonly LI: "li";
    readonly MAX_ENTROPY: "maxEntropy";
    readonly MEAN: "mean";
    readonly MIN_ERROR: "minError";
    readonly MINIMUM: "minimum";
    readonly MOMENTS: "moments";
    readonly OTSU: "otsu";
    readonly PERCENTILE: "percentile";
    readonly RENYI_ENTROPY: "renyiEntropy";
    readonly SHANBHAG: "shanbhag";
    readonly TRIANGLE: "triangle";
    readonly YEN: "yen";
};

export declare type ThresholdAlgorithm = (typeof ThresholdAlgorithm)[keyof typeof ThresholdAlgorithm];

export declare type ThresholdOptions = ThresholdOptionsThreshold | ThresholdOptionsAlgorithm;

export declare interface ThresholdOptionsAlgorithm extends ThresholdOptionsBase {
    /**
     * Specify a function to computes the threshold value.
     *   @default `'otsu'`
     */
    algorithm?: ThresholdAlgorithm;
}

declare interface ThresholdOptionsBase {
    /**
     * Number of slots that histogram can have. Slots must be a power of 2.
     */
    slots?: number;
    /**
     * Image to use as the output.
     */
    out?: Mask;
}

export declare interface ThresholdOptionsThreshold extends ThresholdOptionsBase {
    /**
     * Threshold value that should be used. Threshold is a value in range [0,1],
     * which will be interpreted as a percentage of image.maxValue.
     */
    threshold: number;
}

declare type TiffIfd = ReturnType<typeof decode_2>[number];

export declare function topHat(image: Image_2, options?: TopHatOptions): Image_2;

export declare function topHat(image: Mask, options?: TopHatOptions): Mask;

export declare interface TopHatOptions {
    /**
     * 3x3 matrix. The kernel can only have ones and zeros.
     * Accessing a value: kernel[row][column].
     * @default `[[1, 1, 1], [1, 1, 1], [1, 1, 1]]`
     */
    kernel?: number[][];
    /**
     * Number of iterations of the algorithm.
     * @default `1`
     */
    iterations?: number;
}

/**
 * Transforms an image using a matrix.
 * @param image - Original image.
 * @param transformMatrix - 2×3 transform matrix.
 * @param options - Transform options.
 * @returns The new image.
 */
export declare function transform(image: Image_2, transformMatrix: number[][], options?: TransformOptions): Image_2;

export declare interface TransformOptions {
    /**
     * Width of the output image.
     */
    width?: number;
    /**
     * Height of the output image.
     */
    height?: number;
    /**
     * Method to use to interpolate the new pixels.
     * @default `'bilinear'`
     */
    interpolationType?: InterpolationType;
    /**
     * Specify how the borders should be handled.
     * @default `'constant'`
     */
    borderType?: BorderType;
    /**
     * Value of the border if BorderType is 'constant'.
     *  @default `0`
     */
    borderValue?: number;
    /**
     * Whether the transform matrix should be inverted.
     */
    inverse?: boolean;
    /**
     * Bypasses width and height options to include
     * every pixel of the original image inside the transformed image.
     */
    fullImage?: boolean;
}

/**
 * Rotate an image anti-clockwise of a given angle.
 * @param image - Original image.
 * @param angle - Angle in degrees.
 * @param options - Rotate options.
 * @returns A new rotated image.
 */
export declare function transformRotate(image: Image_2, angle: number, options?: TransformRotateOptions): Image_2;

export declare interface TransformRotateOptions extends TransformOptions {
    /**
     * Specify the rotation center point as a predefined string or a Point.
     * @default `'center'`.
     */
    center?: ImageCoordinates | Point;
    /**
     * Scaling factor for the rotated image.
     *  @default `1`
     */
    scale?: number;
}

/**
 * Compute the variance of each channel of an image.
 * @see {@link https://en.wikipedia.org/wiki/Variance}
 * @param image - Image to process.
 * @param options - Variance options.
 * @returns The variance of the channels of the image.
 */
export declare function variance(image: Image_2, options?: VarianceOptions): number[];

export declare interface VarianceOptions {
    /**
     * Points to calculate variance from.
     */
    points: Point[];
}

/**
 * This method allows to create a ROIMap using the water shed algorithm. By default this algorithm
 * will fill the holes and therefore the lowest value of the image (black zones).
 * If no points are given, the function will look for all the minimal points.
 * If no mask is given the algorithm will completely fill the image.
 * Please take care about the value that has be in the mask ! In order to be coherent with the expected mask,
 * meaning that if it is a dark zone, the mask will be dark the normal behavior to fill a zone
 * is that the mask pixel is clear (value of 0) !
 * If you are looking for 'maxima' the image must be inverted before applying the algorithm
 * @param image - Image that the filter will be applied to.
 * @param options - WaterShedOptions
 * @returns RoiMapManager
 */
export declare function waterShed(image: Image_2, options: WaterShedOptions): RoiMapManager;

export declare interface WaterShedOptions {
    /**
     * @param points - Points which should be filled by watershed filter.
     * @default - minimum points from getExtrema() function.
     */
    points?: Point[];
    /**
     * @param mask - A binary image, the same size as the image. The algorithm will fill only if the current pixel in the binary mask is not null.
     * @default undefined
     */
    mask?: Mask;
    /**
     * @param threshold - Limit of filling. Maximum value that pixel can have.
     * @default 1
     */
    threshold?: number;
}

/**
 * Write an image to the disk.
 * The file format is determined automatically from the file's extension.
 * If the extension is not supported, an error will be thrown.
 * This method is only implemented for Node.js.
 * @param path - Path or file URL where the image should be written.
 * @param image - Image to save.
 * @param options - Write options.
 * @returns A promise that resolves when the image is written.
 */
export declare function write(path: string | URL, image: Image_2 | Mask, options?: WriteOptions): Promise<void>;

/**
 * Write an image to the disk as PNG.
 * When the `png` format is specified, the file's extension doesn't matter.
 * This method is only implemented for Node.js.
 * @param path - Path or file URL where the image should be written.
 * @param image - Image to save.
 * @param options - Encode options for png images.
 * @returns A promise that resolves when the image is written.
 */
export declare function write(path: string | URL, image: Image_2 | Mask, options: WriteOptionsPng): Promise<void>;

/**
 * Write an image to the disk as JPEG.
 * When the `jpeg` format is specified, the file's extension doesn't matter.
 * This method is only implemented for Node.js.
 * @param path - Path or file URL where the image should be written.
 * @param image - Image to save.
 * @param options - Encode options for jpeg images.
 * @returns A promise that resolves when the image is written.
 */
export declare function write(path: string | URL, image: Image_2 | Mask, options: WriteOptionsJpeg): Promise<void>;

/**
 * Write an image to the disk as BMP.
 * When the `bmp` format is specified, the file's extension doesn't matter.
 * This method is only implemented for Node.js.
 * @param path - Path or file URL where the image should be written.
 * @param image - Image to save.
 * @param options - Encode options for bmp images.
 * @returns A promise that resolves when the image is written.
 */
export declare function write(path: string | URL, image: Mask, options?: WriteOptionsBmp): Promise<void>;

/**
 * Draw the image in an HTML canvas.
 * @param image - The image to draw.
 * @param canvas - The HTML canvas.
 * @param options - Write canvas options.
 */
export declare function writeCanvas(image: Image_2 | Mask, canvas: HTMLCanvasElement, options?: WriteCanvasOptions): void;

export declare interface WriteCanvasOptions {
    /**
     * If set to `true`, the canvas element will be resized to fit the image.
     * @default `true`
     */
    resizeCanvas?: boolean;
    /**
     * @default `0`
     */
    dx?: number;
    /**
     *  @default `0`
     */
    dy?: number;
    /**
     * @default `0`
     */
    dirtyX?: number;
    /**
     * @default `0`
     */
    dirtyY?: number;
    /**
     * @default `image.width`
     */
    dirtyWidth?: number;
    /**
     * @default `image.height`
     */
    dirtyHeight?: number;
}

export declare interface WriteOptions {
    /**
     * If true, attempts to create all the missing directories recursively.
     */
    recursive?: boolean;
}

export declare type WriteOptionsBmp = WriteOptions & EncodeOptionsBmp;

export declare type WriteOptionsJpeg = WriteOptions & EncodeOptionsJpeg;

export declare type WriteOptionsPng = WriteOptions & EncodeOptionsPng;

/**
 * Synchronous version of @see {@link write}.
 * This method is only implemented for Node.js.
 * @param path - Path where the image should be written.
 * @param image - Image to save.
 * @param options - Encode options.
 */
export declare function writeSync(path: string | URL, image: Image_2 | Mask, options?: WriteOptionsBmp | WriteOptionsPng | WriteOptionsJpeg | WriteOptions): void;

export { }
