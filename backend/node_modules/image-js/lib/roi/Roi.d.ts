import type { Mask } from '../Mask.js';
import type { Feret, GetBorderPointsOptions, Mbr } from '../maskAnalysis/index.js';
import type { Point } from '../utils/geometry/points.js';
import type { RoiMap } from './RoiMapManager.js';
import type { GetMaskOptions } from './getMask.js';
import type { Border, Ellipse } from './roi.types.js';
export declare class Roi {
    #private;
    /**
     * Original map with all the ROI IDs.
     */
    private readonly map;
    /**
     * ID of the ROI. Positive for white ROIs and negative for black ones.
     */
    readonly id: number;
    /**
     * Origin of the ROI. The top-left corner of the rectangle around
     * the ROI relative to the original image.
     */
    readonly origin: Point;
    /**
     * Width of the ROI.
     */
    readonly width: number;
    /**
     * Height of the ROI.
     */
    readonly height: number;
    /**
     * Surface of the ROI.
     */
    readonly surface: number;
    constructor(map: RoiMap, id: number, width: number, height: number, origin: Point, surface: number);
    /**
     * Return the value at the given coordinates in an ROI map.
     * @param column - Column of the value.
     * @param row - Row of the value.
     * @returns The value at the given coordinates.
     */
    getMapValue(column: number, row: number): number;
    /**
     * Returns the ratio between the width and the height of the bounding rectangle of the ROI.
     * @returns The width by height ratio.
     */
    getRatio(): number;
    /**
     * Generates a mask of an ROI. You can specify the kind of mask you want using the `kind` option.
     * @param options - Get Mask options.
     * @returns The ROI mask.
     */
    getMask(options?: GetMaskOptions): Mask;
    /**
     * Computes the diameter of a circle that has the same perimeter as the particle image.
     * @returns Ped value in pixels.
     */
    get ped(): number;
    /**
     * Return an array with the coordinates of the pixels that are on the border of the ROI.
     * The points are defined as [column, row].
     * @param options - Get border points options.
     * @returns The array of border pixels.
     */
    getBorderPoints(options?: GetBorderPointsOptions): Point[];
    /**
     * Returns an array of ROIs IDs that are included in the current ROI.
     * This will be useful to know if there are some holes in the ROI.
     * @returns InternalIDs.
     */
    get internalIDs(): number[];
    /**
     * Returns an array of ROIs IDs that touch the current ROI.
     * @returns The array of Borders.
     */
    get externalBorders(): Border[];
    /**
     * Calculates and caches the number of sides by which each pixel is touched externally.
     * @returns An object which tells how many pixels are exposed externally to how many sides.
     */
    get perimeterInfo(): {
        one: number;
        two: number;
        three: number;
        four: number;
    };
    /**
     * Perimeter of the ROI.
     * The perimeter is calculated using the sum of all the external borders of the ROI to which we subtract:
     * (2 - √2) * the number of pixels that have 2 external borders
     * 2 * (2 - √2) * the number of pixels that have 3 external borders
     * @returns Perimeter value in pixels.
     */
    get perimeter(): number;
    /**
     * Computes ROI points relative to ROIs point of `origin`.
     * @returns Array of points with relative ROI coordinates.
     */
    get relativePoints(): Point[];
    /**
     * Computes ROI points relative to Image's/Mask's point of `origin`.
     * @returns Array of points with absolute ROI coordinates.
     */
    get absolutePoints(): Point[];
    get boxIDs(): number[];
    /**
     * Computes the diameter of a circle of equal projection area (EQPC).
     * It is a diameter of a circle that has the same surface as the ROI.
     * @returns `eqpc` value in pixels.
     */
    get eqpc(): number;
    /**
     * Computes ellipse of ROI. It is the smallest ellipse that fits the ROI.
     * @returns Ellipse
     */
    get ellipse(): Ellipse;
    /**
     * Number of holes in the ROI and their total surface.
     * Used to calculate fillRatio.
     * @returns The surface of holes in ROI in pixels.
     */
    get holesInfo(): {
        number: number;
        surface: number;
    };
    /**
     * Calculates and caches border's length and their IDs.
     * @returns Borders' length and their IDs.
     */
    get borders(): Border[];
    /**
     * Computes fill ratio of the ROI. It is calculated by dividing ROI's actual surface over the surface combined with holes, to see how holes affect its surface.
     * @returns Fill ratio value.
     */
    get fillRatio(): number;
    /**
     * Computes sphericity of the ROI.
     * Sphericity is a measure of the degree to which a particle approximates the shape of a sphere, and is independent of its size. The value is always between 0 and 1. The less spheric the ROI is the smaller is the number.
     * @returns Sphericity value.
     */
    get sphericity(): number;
    /**
     * Computes the surface of the ROI, including the surface of the holes.
     * @returns Surface including holes measured in pixels.
     */
    get filledSurface(): number;
    /**
     * The solidity describes the extent to which a shape is convex or concave.
     * The solidity of a completely convex shape is 1, the farther the it deviates from 1, the greater the extent of concavity in the shape of the ROI.
     * @returns Solidity value.
     */
    get solidity(): number;
    /**
     *Computes convex hull. It is the smallest convex set that contains it.
     * @see https://en.wikipedia.org/wiki/Convex_hull
     * @returns Convex hull.
     */
    get convexHull(): {
        points: Point[];
        surface: number;
        perimeter: number;
    };
    /**
     * Computes the minimum bounding rectangle.
     * In digital image processing, the bounding box is merely the coordinates of the rectangular border that fully encloses a digital image when it is placed over a page, a canvas, a screen or other similar bidimensional background.
     * @returns The minimum bounding rectangle.
     */
    get mbr(): Mbr;
    get roundness(): number;
    /**
     * This is not a diameter in its actual sense but the common basis of a group of diameters derived from the distance of two tangents to the contour of the particle in a well-defined orientation.
     * In simpler words, the method corresponds to the measurement by a slide gauge (slide gauge principle).
     * In general it is defined as the distance between two parallel tangents of the particle at an arbitrary angle. The minimum Feret diameter is often used as the diameter equivalent to a sieve analysis.
     * @returns The maximum and minimum Feret Diameters.
     */
    get feret(): Feret;
    /**
     * A JSON object with all the data about ROI.
     * @returns All current ROI properties as one object.
     */
    toJSON(): {
        id: number;
        origin: Point;
        height: number;
        width: number;
        surface: number;
        eqpc: number;
        ped: number;
        feret: Feret;
        fillRatio: number;
        sphericity: number;
        roundness: number;
        solidity: number;
        perimeter: number;
        convexHull: {
            points: Point[];
            surface: number;
            perimeter: number;
        };
        mbr: Mbr;
        filledSurface: number;
        centroid: Point;
    };
    /**
     * Computes a center of mass of the current ROI.
     * @returns point
     */
    get centroid(): Point;
    /**
     * Generator function to calculate point's coordinates.
     * @param absolute - controls whether coordinates should be relative to ROI's point of `origin` (relative), or relative to ROI's position on the Image/Mask (absolute).
     * @yields Coordinates of each point of ROI.
     */
    points(absolute: boolean): Generator<{
        column: number;
        row: number;
    }, void, unknown>;
}
//# sourceMappingURL=Roi.d.ts.map