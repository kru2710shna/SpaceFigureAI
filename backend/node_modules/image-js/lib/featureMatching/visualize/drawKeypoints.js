import { sum } from '../../utils/geometry/points.js';
import { getOutputImage } from '../../utils/getOutputImage.js';
import { getColors } from '../utils/getColors.js';
import { getKeypointColor } from '../utils/getKeypointColor.js';
/**
 * Draw keypoints on an image.
 * @param image - The source image of the keypoints.
 * @param keypoints - The FAST keypoints.
 * @param options - Draw keypoints options.
 * @returns The image with the keypoints indicated by empty circles.
 */
export function drawKeypoints(image, keypoints, options = {}) {
    const { markerSize = 10, fill = false, showScore = false, origin = { row: 0, column: 0 }, showScoreOptions, } = options;
    let { maxNbKeypoints = keypoints.length } = options;
    const { strokeColor = [255, 0, 0] } = options;
    if (maxNbKeypoints > keypoints.length) {
        maxNbKeypoints = keypoints.length;
    }
    let newImage = getOutputImage(image, options, { clone: true });
    if (image.colorModel !== 'RGB') {
        newImage = newImage.convertColor('RGB');
    }
    const colors = getColors(image, strokeColor, showScoreOptions);
    const radius = Math.ceil(markerSize / 2);
    for (let i = 0; i < maxNbKeypoints; i++) {
        const keypoint = keypoints[i];
        let keypointColor = strokeColor;
        if (showScore) {
            keypointColor = getKeypointColor(keypoints, i, colors);
        }
        const fillColor = fill ? keypointColor : undefined;
        const absoluteOrigin = sum(keypoint.origin, origin);
        newImage.drawCircle(absoluteOrigin, radius, {
            fillColor,
            strokeColor: keypointColor,
            out: newImage,
        });
        if (isOrientedFastKeypoint(keypoint) &&
            options.showOrientation) {
            const angle = keypoint.angle;
            const from = absoluteOrigin;
            const radAngle = (angle * Math.PI) / 180;
            const to = {
                column: from.column + Math.round(radius * Math.cos(radAngle)),
                row: from.row - Math.round(radius * Math.sin(radAngle)),
            };
            newImage.drawLine(from, to, {
                strokeColor: keypointColor,
                out: newImage,
            });
        }
    }
    return newImage;
}
function isOrientedFastKeypoint(kpt) {
    return 'angle' in kpt && typeof kpt.angle === 'number';
}
//# sourceMappingURL=drawKeypoints.js.map