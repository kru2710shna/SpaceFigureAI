import arrayMedian from 'ml-array-median';
import Random from 'ml-random';
import { getNbIterations } from './utils/getNbIterations';
/**
 * RANdom SAmple Consensus algorithm: find the best model matching the data and ignoring outliers.
 *
 * @see https://en.wikipedia.org/wiki/Random_sample_consensus
 * @param source - The source data.
 * @param destination - The destination data.
 * @param options - RANSAC options.
 * @returns The model parameters and the corresponding inliers.
 */
export function ransac(source, destination, options) {
    let minNbInliers = 0;
    if (options.minNbInliers) {
        minNbInliers = getNbValues(options.minNbInliers, source.length);
    }
    else {
        minNbInliers = source.length;
    }
    const { sampleSize = 2, threshold = 1, fitFunction, distanceFunction, modelFunction, seed = undefined, } = options;
    if (source.length !== destination.length) {
        throw new Error('source and destination data should have the same length');
    }
    let maxNbIterations;
    if ('outliersFraction' in options) {
        const { stopProbabilty = 0.99 } = options;
        maxNbIterations = getNbIterations(stopProbabilty, options.outliersFraction, sampleSize);
    }
    else {
        maxNbIterations = options.maxNbIterations ? options.maxNbIterations : 100;
    }
    let iteration = 0;
    let bestNbInliers = 0;
    let bestInliers = [];
    let bestModelParameters = [];
    let bestError = 0;
    let seeds = [];
    if (seed !== undefined) {
        seeds = new Random(seed).choice(maxNbIterations, {
            size: maxNbIterations,
        });
    }
    while (iteration < maxNbIterations) {
        iteration++;
        let indices;
        if (seed !== undefined) {
            indices = new Random(seeds[iteration]).choice(source.length, {
                size: sampleSize,
            });
        }
        else {
            indices = new Random().choice(source.length, {
                size: sampleSize,
            });
        }
        const srcSubset = [];
        const dstSubset = [];
        for (let i of indices) {
            srcSubset.push(source[i]);
            dstSubset.push(destination[i]);
        }
        const modelParameters = fitFunction(srcSubset, dstSubset);
        const model = modelFunction(modelParameters);
        let predictedDestination = [];
        for (let value of source) {
            predictedDestination.push(model(value));
        }
        let nbInliers = 0;
        let inliers = [];
        let distances = [];
        let error = 0;
        for (let i = 0; i < destination.length; i++) {
            if (indices.includes(i)) {
                nbInliers++;
                inliers.push(i);
                continue;
            }
            const distance = distanceFunction(destination[i], predictedDestination[i]);
            distances.push(distance);
            if (distance < threshold) {
                nbInliers++;
                inliers.push(i);
            }
        }
        error = arrayMedian(distances);
        if (nbInliers > bestNbInliers) {
            bestNbInliers = nbInliers;
            bestInliers = inliers; // potential bug with pointers?
            bestModelParameters = modelParameters;
            bestError = error;
            if (nbInliers >= minNbInliers) {
                return { modelParameters, inliers, nbIterations: iteration, error };
            }
        }
    }
    return {
        modelParameters: bestModelParameters,
        inliers: bestInliers,
        nbIterations: maxNbIterations,
        error: bestError,
    };
}
function getNbValues(value, size) {
    if (Number.isInteger(value)) {
        return value;
    }
    else {
        return Math.ceil(value * size);
    }
}
//# sourceMappingURL=index.js.map